<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Cleyton Farias</title>
    <link>https://cleytonfar.github.io/posts/</link>
    <description>Recent content in Posts on Cleyton Farias</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 25 Mar 2019 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://cleytonfar.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Using Julia for Data Science (Part 03): Plotting</title>
      <link>https://cleytonfar.github.io/posts/using-julia-for-data-science-part-03/</link>
      <pubDate>Mon, 25 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cleytonfar.github.io/posts/using-julia-for-data-science-part-03/</guid>
      <description>


&lt;p&gt;The &lt;strong&gt;Julia&lt;/strong&gt; plotting system is available from a set of packages each one using its own
syntax. The most important examples are the &lt;strong&gt;Plots&lt;/strong&gt; and &lt;strong&gt;Gadfly&lt;/strong&gt; packages.
In this post, we will take a look at the basic functionalities from these libraries.&lt;/p&gt;
&lt;p&gt;Before we start playing around, the first thing to do is to install the necessary
packages:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;using Pkg
Pkg.add(&amp;quot;Plots&amp;quot;)
Pkg.add(&amp;quot;GR&amp;quot;)
Pkg.add(&amp;quot;PyPlot&amp;quot;)
Pkg.add(&amp;quot;Gadfly&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now let’s get started!!&lt;/p&gt;
&lt;div id=&#34;the-plots-package&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;The Plots package&lt;/h1&gt;
&lt;p&gt;The most basic plot that we can do is a &lt;em&gt;line&lt;/em&gt; plot. We can plot a line by calling
the &lt;code&gt;plot()&lt;/code&gt; function on two vectors:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;using Plots
x = 1:10;
y = rand(10, 1);
plot(x, y)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://cleytonfar.github.io/posts/2019-03-20-using-julia-for-data-science-part-03_files/figure-html/unnamed-chunk-1-J1.png&#34; width=&#34;50%&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;Plots&lt;/strong&gt;, every column is treated as a &lt;em&gt;series&lt;/em&gt;. Thus, we can plot multiple
lines by plotting a matrix of values where each column will be interpreted as a
different serie:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;y = rand(10, 2);
p = plot(x, y)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://cleytonfar.github.io/posts/2019-03-20-using-julia-for-data-science-part-03_files/figure-html/unnamed-chunk-2-J1.png&#34; width=&#34;50%&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We can modify an existing plot by using the modifier function &lt;code&gt;plot!()&lt;/code&gt;. For instance,
let’s add one more line to the previous plot:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;z = rand(10);
## adding line z to plot p:
plot!(p, x, z) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://cleytonfar.github.io/posts/2019-03-20-using-julia-for-data-science-part-03_files/figure-html/unnamed-chunk-3-J1.png&#34; width=&#34;50%&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Notice that I specified the plot (&lt;code&gt;p&lt;/code&gt;) to be modified on the last calling. We could
just call &lt;code&gt;plot!(x, z)&lt;/code&gt; and the plot &lt;code&gt;p&lt;/code&gt; would be modified because the &lt;strong&gt;Plots&lt;/strong&gt;
package will look for the latest plot to apply the modifications.&lt;/p&gt;
&lt;div id=&#34;plots-attributes&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Plots Attributes&lt;/h2&gt;
&lt;p&gt;Not only we want to make plots, but also make them look nice, right?! So, in order
to do that we can tweak the plot &lt;strong&gt;attributes&lt;/strong&gt;. The &lt;strong&gt;Plots&lt;/strong&gt; package follows a simple
rule with &lt;em&gt;data&lt;/em&gt; vs &lt;em&gt;attributes&lt;/em&gt;: &lt;em&gt;positional&lt;/em&gt; arguments are input data, and &lt;em&gt;keyword&lt;/em&gt;
arguments are attributes. For instance, calling &lt;code&gt;plot(x, y, z)&lt;/code&gt; will produce a 3-D plot, while
calling &lt;code&gt;plot(x, y, attribute = value)&lt;/code&gt; will output a 2D plot with an attribute.
To illustrate this, let’s add a &lt;em&gt;title&lt;/em&gt; and modify the &lt;em&gt;legend labels&lt;/em&gt; for our previous plot:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;p = plot(x, y, 
     title = &amp;quot;My beautiful Plot&amp;quot;, ## adding a title
     label = [&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;]) ## adding legend labels&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://cleytonfar.github.io/posts/2019-03-20-using-julia-for-data-science-part-03_files/figure-html/unnamed-chunk-4-J1.png&#34; width=&#34;50%&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Additionally, we can use &lt;em&gt;modifiers functions&lt;/em&gt; to customize our plots. For example,
let’s say we wanted to add a label for the y-axis and x-axis. We could just add
the argument &lt;code&gt;xlabel = &#34;...&#34;&lt;/code&gt; and &lt;code&gt;ylabel = &#34;...&#34;&lt;/code&gt; on the last call, or we could
use the modifier functions &lt;code&gt;xlabel!()&lt;/code&gt; and &lt;code&gt;ylabel!()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;xlabel!(p, &amp;quot;My customized x label&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://cleytonfar.github.io/posts/2019-03-20-using-julia-for-data-science-part-03_files/figure-html/unnamed-chunk-5-J1.png&#34; width=&#34;50%&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;ylabel!(p, &amp;quot;My customized y label&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://cleytonfar.github.io/posts/2019-03-20-using-julia-for-data-science-part-03_files/figure-html/unnamed-chunk-5-J2.png&#34; width=&#34;50%&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Also, we can customize the line colors, as well as adding markers and even annotations
to the plot:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;markershapes= [:circle :star5];
markercolors= [:orange :green];
plot(x, y,
     title = &amp;quot;My beautiful Plot&amp;quot;,
     xlabel = &amp;quot;My customized x label&amp;quot;,
     ylabel = &amp;quot;My customized y label&amp;quot;,
     label = [&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;],
     color = markercolors,
     shape = markershapes,
     annotation = [(4, .9, &amp;quot;Look at me!!&amp;quot;)])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://cleytonfar.github.io/posts/2019-03-20-using-julia-for-data-science-part-03_files/figure-html/unnamed-chunk-6-J1.png&#34; width=&#34;50%&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Of course, not only plotting lines can a data scientist survive, right?! In &lt;strong&gt;Plots&lt;/strong&gt;,
we can make other types of plots just by adjusting the &lt;code&gt;seriestype = &#34;...&#34;&lt;/code&gt; attribute.
For instance, instead of a line plot, we can make a &lt;em&gt;scatter&lt;/em&gt; plot:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;x = rand(20);
y = rand(20);
plot(x, y, seriestype = :scatter, legend = false, color = [:blue])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://cleytonfar.github.io/posts/2019-03-20-using-julia-for-data-science-part-03_files/figure-html/unnamed-chunk-7-J1.png&#34; width=&#34;50%&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Also, we can make a &lt;em&gt;bar&lt;/em&gt; plot:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;x = 1:10;
y = sin.(x);
plot(x, y, seriestype = :bar, legend = false)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://cleytonfar.github.io/posts/2019-03-20-using-julia-for-data-science-part-03_files/figure-html/unnamed-chunk-8-J1.png&#34; width=&#34;50%&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;and to make a &lt;strong&gt;histogram&lt;/strong&gt;, we can do:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;using LaTeXStrings
mathstring = L&amp;quot;X \sim \mathcal{N}(0,\,1)&amp;quot;;
plot(randn(1000), seriestype = :histogram, legend = false, title = mathstring)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://cleytonfar.github.io/posts/2019-03-20-using-julia-for-data-science-part-03_files/figure-html/unnamed-chunk-9-J1.png&#34; width=&#34;50%&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Notice that we can also add LaTeX notation in the plot using the functionalities
from the &lt;strong&gt;LaTeXStrings&lt;/strong&gt; package.&lt;/p&gt;
&lt;p&gt;There are a large numbers of plot attributes we can tweak. This is just the tip of
the iceberg. For more detail, please refer to &lt;a href=&#34;http://docs.juliaplots.org/latest/tutorial/#tutorial-1&#34;&gt;official documentation&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;plot-backend&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Plot Backend&lt;/h2&gt;
&lt;p&gt;Now, let me tell something:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Plots&lt;/strong&gt; is not a plotting package!!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;What??? That’s right!! &lt;strong&gt;Plots&lt;/strong&gt; is what is called a &lt;em&gt;metapackage&lt;/em&gt;. Its aim is to
bring many different plotting packages under a single API (interface). What do you mean by that, Cleyton?&lt;/p&gt;
&lt;p&gt;Well… in &lt;strong&gt;Julia&lt;/strong&gt; we have access to different plotting packages such as &lt;strong&gt;PyPlot&lt;/strong&gt; (Python’s matplotlib),
&lt;a href=&#34;https://plot.ly/&#34;&gt;&lt;strong&gt;Plotly&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&#34;http://gr-framework.org/about.html&#34;&gt;&lt;strong&gt;GR&lt;/strong&gt;&lt;/a&gt; and some others.
Each one have different features which can be very useful for certain situations.
However each one has its own syntax. So, in order to get the most from these packages,
you would have to learn their syntax.&lt;/p&gt;
&lt;p&gt;That’s when &lt;strong&gt;Plots&lt;/strong&gt; comes at hand! Instead of learning different syntaxes, &lt;strong&gt;Plots&lt;/strong&gt;
package provides you access to different plotting packages (called &lt;strong&gt;backends&lt;/strong&gt;)
using just one single syntax. Then, &lt;strong&gt;Plots&lt;/strong&gt; interprets your commands and then generates
the plots using another plotting library. That is, this means you can use many
different plotting libraries, all with the &lt;strong&gt;Plots&lt;/strong&gt; syntax, only by specifying which
&lt;strong&gt;backend&lt;/strong&gt; you want to use. That’s it! Just like that!.&lt;/p&gt;
&lt;p&gt;Up until now, our plot was using the default backend. The default depends in what
plotting package you have installed in &lt;strong&gt;Julia&lt;/strong&gt;. Some common choices for backends (plotting package)
are &lt;strong&gt;PyPlot&lt;/strong&gt; and &lt;strong&gt;GR&lt;/strong&gt;. To install these backends, simply use the standard &lt;strong&gt;Julia&lt;/strong&gt;
installation &lt;code&gt;Pkg.add(&#34;BackendPackage&#34;)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In order to specify which backend we want to use just use the name of the backend
in lower case as a function:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;x = 1:10;
y = rand(10, 2);
## specifying pyplot backend:
pyplot()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Plots.PyPlotBackend()&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;plot(x, y, title = &amp;quot;using Pyplot&amp;quot;, shape = :cirle)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://cleytonfar.github.io/posts/2019-03-20-using-julia-for-data-science-part-03_files/figure-html/unnamed-chunk-10-J1.png&#34; width=&#34;50%&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;See?! Very easy! You can kepp changing the backend back and forth just like that.
The choice of backend depends on the situation. Usually, I prefer to use &lt;strong&gt;Plotly&lt;/strong&gt;
when I want to make interactivity plots, &lt;strong&gt;GR&lt;/strong&gt; to make simple and quick plots (for example, in an exploratory data analysis situation), and &lt;strong&gt;PyPlot&lt;/strong&gt; otherwise.&lt;/p&gt;
&lt;p&gt;In order to save the plots we use the &lt;code&gt;savefig()&lt;/code&gt; command:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# saves the current plot:
savefig(&amp;quot;myplot.png&amp;quot;) 
# saves the plot from p:
savefig(p,&amp;quot;myplot.pdf&amp;quot;) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For more information on backends, please refer to the &lt;a href=&#34;http://docs.juliaplots.org/latest/backends/#backends-1&#34;&gt;official documentation&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;recipe-libraries&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Recipe Libraries&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Recipes&lt;/strong&gt; libraries are extensions that we can use with &lt;strong&gt;Plots&lt;/strong&gt; framework.
They add more functionalities such as default interpretation for certain types,
new series types, and many others.&lt;/p&gt;
&lt;p&gt;One of the most important recipe libraries is &lt;strong&gt;StatsPlots&lt;/strong&gt;, a package comprising
a set of new statistical plot series for a certain data type. We can install this
library using &lt;code&gt;Pkg.add(&#34;StatsPlots&#34;)&lt;/code&gt; command. The &lt;strong&gt;StatsPlots&lt;/strong&gt; package
has a macro &lt;code&gt;@df&lt;/code&gt; which allows you to plot a &lt;strong&gt;DataFrame&lt;/strong&gt; directly by using the
column names. We can specify the column names either as &lt;em&gt;symbol&lt;/em&gt; (:column_name) or
as &lt;em&gt;string&lt;/em&gt; (“column_name”):&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;using StatsPlots
using DataFrames
## creating a random DataFrame
df = DataFrame(a = 1:10, b = rand(10), c = rand(10));
## Plotting using the @df macro specifying colum names as symbol:
@df df plot(:a, [:b :c], color = [:red :blue])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://cleytonfar.github.io/posts/2019-03-20-using-julia-for-data-science-part-03_files/figure-html/unnamed-chunk-11-J1.png&#34; width=&#34;50%&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We can also make a call for &lt;code&gt;@df&lt;/code&gt; using the &lt;code&gt;cols()&lt;/code&gt; utility function. This function
allows us to specify the column using a positional index:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@df df plot(:a, cols(2:3), color = [:red :blue])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;StatsPlots&lt;/strong&gt; also contains the &lt;code&gt;corrplot()&lt;/code&gt; and &lt;code&gt;cornerplot()&lt;/code&gt; functions to plot
the correlation among input variables:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;@df df corrplot(cols(2:3))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://cleytonfar.github.io/posts/2019-03-20-using-julia-for-data-science-part-03_files/figure-html/unnamed-chunk-12-J1.png&#34; width=&#34;50%&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;@df df cornerplot(cols(2:3))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://cleytonfar.github.io/posts/2019-03-20-using-julia-for-data-science-part-03_files/figure-html/unnamed-chunk-12-J2.png&#34; width=&#34;50%&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Of course, there are more functionalities from the &lt;strong&gt;StatsPlots&lt;/strong&gt; library
than I have showed here. For more detail, please refer to &lt;a href=&#34;https://github.com/JuliaPlots/StatsPlots.jl&#34;&gt;official documentation&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;the-gadfly-package&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;The Gadfly Package&lt;/h1&gt;
&lt;p&gt;Now, let me be honest with you: this is my favorite one!! &lt;strong&gt;Gadfly&lt;/strong&gt; is another
package used to create beautiful plots in &lt;strong&gt;Julia&lt;/strong&gt;. This package is an implementation
of the “&lt;em&gt;grammar of graphics&lt;/em&gt;”style. For those who have &lt;strong&gt;R&lt;/strong&gt; experience, this is
the same principle used in the wonderful &lt;em&gt;ggplot2&lt;/em&gt; package.&lt;/p&gt;
&lt;p&gt;In order to start playing with &lt;strong&gt;Gadfly&lt;/strong&gt;, we need some data. Let’s make use of the
&lt;strong&gt;RDatasets&lt;/strong&gt; package which give us access to a &lt;a href=&#34;https://vincentarelbundock.github.io/Rdatasets/datasets.html&#34;&gt;list&lt;/a&gt; of the datasets available from &lt;strong&gt;R&lt;/strong&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Pkg.add(&amp;quot;RDatasets&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When used with a &lt;code&gt;DataFrame&lt;/code&gt;, we can use the &lt;code&gt;plot()&lt;/code&gt; function with the following syntax:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;plot(data::DataFrame, x = :column_name, y = :column_name, geometry)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;where the &lt;em&gt;geometry&lt;/em&gt; argument is just the series type you want to plot: a &lt;em&gt;line&lt;/em&gt;, &lt;em&gt;point&lt;/em&gt;,
&lt;em&gt;error bar&lt;/em&gt;, &lt;em&gt;histogram&lt;/em&gt;, etc.
Notice something: &lt;strong&gt;Plots&lt;/strong&gt; and &lt;strong&gt;Gadfly&lt;/strong&gt; use the same name for the plotting function.
To avoid confusion in &lt;strong&gt;Julia&lt;/strong&gt; about which &lt;code&gt;plot()&lt;/code&gt; function to call, we can specify
from which package we want the call to be made by using the &lt;code&gt;Gadfly.plot()&lt;/code&gt; syntax.
For those who have an &lt;strong&gt;R&lt;/strong&gt; background, this syntax is equivalent to &lt;em&gt;name_package&lt;/em&gt;::function_name()
in &lt;strong&gt;R&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Now, let’s use the &lt;strong&gt;iris&lt;/strong&gt; dataset to start playing around with &lt;strong&gt;Gadfly&lt;/strong&gt;:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;using RDatasets
iris = dataset(&amp;quot;datasets&amp;quot;, &amp;quot;iris&amp;quot;);
first(iris, 5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 5×5 DataFrame
## │ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species      │
## │     │ Float64     │ Float64    │ Float64     │ Float64    │ Categorical… │
## ├─────┼─────────────┼────────────┼─────────────┼────────────┼──────────────┤
## │ 1   │ 5.1         │ 3.5        │ 1.4         │ 0.2        │ setosa       │
## │ 2   │ 4.9         │ 3.0        │ 1.4         │ 0.2        │ setosa       │
## │ 3   │ 4.7         │ 3.2        │ 1.3         │ 0.2        │ setosa       │
## │ 4   │ 4.6         │ 3.1        │ 1.5         │ 0.2        │ setosa       │
## │ 5   │ 5.0         │ 3.6        │ 1.4         │ 0.2        │ setosa       │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, let’s plot a &lt;em&gt;scatter&lt;/em&gt; plot using &lt;em&gt;SepalLength&lt;/em&gt; and &lt;em&gt;SepalWidth&lt;/em&gt; variables.
To specify that we want a scatter plot, we must set the &lt;em&gt;geometry&lt;/em&gt; element using
&lt;code&gt;Geom.point&lt;/code&gt; argument:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;using Gadfly
Gadfly.plot(iris, x = :SepalLength, y = :SepalWidth, Geom.point)&lt;/code&gt;&lt;/pre&gt;
&lt;center&gt;
&lt;img src=&#34;https://cleytonfar.github.io/images/figure_posts/gadfly_plot1.svg&#34; height=&#34;500&#34; width=&#34;700&#34; /&gt;
&lt;/center&gt;
&lt;p&gt;We can keep adding &lt;em&gt;geometries&lt;/em&gt; to produce more layers in the plot. For instance, we
can add lines to the plot just adding the &lt;code&gt;Geom.line&lt;/code&gt; argument:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Gadfly.plot(iris, x = :SepalLength, y = :SepalWidth, Geom.point, Geom.line)&lt;/code&gt;&lt;/pre&gt;
&lt;center&gt;
&lt;img src=&#34;https://cleytonfar.github.io/images/figure_posts/gadfly_plot2.svg&#34; height=&#34;500&#34; width=&#34;700&#34; /&gt;
&lt;/center&gt;
&lt;p&gt;Also, we can set the keyword argument &lt;code&gt;color&lt;/code&gt; according to some variable to specify
how to color the points:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Gafdfly.plot(iris, x = :SepalLength, y = :SepalWidth, color = :Species, Geom.point)&lt;/code&gt;&lt;/pre&gt;
&lt;center&gt;
&lt;img src=&#34;https://cleytonfar.github.io/images/figure_posts/gadfly_plot3.svg&#34; height=&#34;500&#34; width=&#34;700&#34; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;Gadfly&lt;/strong&gt; has some special signatures to make plotting functions and expressions
more convenient:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Gadfly.plot((x,y) -&amp;gt; sin(x) + cos(y), 0, 2pi, 0, 2pi)&lt;/code&gt;&lt;/pre&gt;
&lt;center&gt;
&lt;img src=&#34;https://cleytonfar.github.io/images/figure_posts/gadfly_plot4.svg&#34; height=&#34;500&#34; width=&#34;700&#34; /&gt;
&lt;/center&gt;
&lt;p&gt;So, as you have noticed that the call from &lt;code&gt;Gadfly.plot()&lt;/code&gt; will render the image to your default
multimedia display, typically an internet browser. To be honest, I do not know why this the
default behavior. In order to render the plot to a file, &lt;strong&gt;Gadfly&lt;/strong&gt; supports creating SVG images out of the box.
The &lt;strong&gt;PNG&lt;/strong&gt;, &lt;strong&gt;PDF&lt;/strong&gt;, &lt;strong&gt;PS&lt;/strong&gt;, and &lt;strong&gt;PGF&lt;/strong&gt; formats require &lt;strong&gt;Julia&lt;/strong&gt;’s bindings to cairo
and fontconfig, which can be installed with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Pkg.add(&amp;quot;Cairo&amp;quot;)
Pkg.add(&amp;quot;Fontconfig&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To save to a file, we use the &lt;code&gt;draw()&lt;/code&gt; function on the chosen backend:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p = Gadfly.plot((x,y) -&amp;gt; sin(x) + cos(y), 0, 2pi, 0, 2pi);
## saving to a pdf device:
draw(PDF(&amp;quot;plot.pdf&amp;quot;, p))
## or to a png device
draw(PNG(&amp;quot;plot.pdf&amp;quot;, p))&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;geometries&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Geometries&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Gadfly&lt;/strong&gt; presents a lot of &lt;em&gt;geometry&lt;/em&gt; format options. As we have seen, to plot more
geometries to a figure we can just add more geometry types. The most common ones are
&lt;code&gt;Geom.line&lt;/code&gt;, &lt;code&gt;Geom.point&lt;/code&gt;, &lt;code&gt;Geom.bar&lt;/code&gt;, &lt;code&gt;Geom.boxplot&lt;/code&gt;, &lt;code&gt;Geom.histogram&lt;/code&gt;,
&lt;code&gt;Geom.errorbar&lt;/code&gt;, &lt;code&gt;Geom.density&lt;/code&gt;, etc.&lt;/p&gt;
&lt;p&gt;We already saw &lt;code&gt;Geom.line&lt;/code&gt; and &lt;code&gt;Geom.point&lt;/code&gt;. So now let’s plot the other geometry types
in one figure using the &lt;code&gt;gridstack()&lt;/code&gt; function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p1 = Gadfly.plot(dataset(&amp;quot;ggplot2&amp;quot;, &amp;quot;diamonds&amp;quot;), x= :Price, Geom.histogram);
p2 = Gadfly.plot(dataset(&amp;quot;HistData&amp;quot;, &amp;quot;ChestSizes&amp;quot;), x = :Chest, y = :Count, Geom.bar);
p3 = Gadfly.plot(dataset(&amp;quot;lattice&amp;quot;, &amp;quot;singer&amp;quot;), x = :VoicePart, y = :Height, Geom.boxplot);
p4 = Gadfly.plot(dataset(&amp;quot;ggplot2&amp;quot;, &amp;quot;diamonds&amp;quot;), x = :Price, Geom.density);
gridstack([p1 p2; p3 p4])&lt;/code&gt;&lt;/pre&gt;
&lt;center&gt;
&lt;img src=&#34;https://cleytonfar.github.io/images/figure_posts/gadfly_plot5.svg&#34; height=&#34;500&#34; width=&#34;700&#34; /&gt;
&lt;/center&gt;
&lt;/div&gt;
&lt;div id=&#34;theme&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Theme&lt;/h2&gt;
&lt;p&gt;We can tweak the plot appearance by using the &lt;code&gt;Theme()&lt;/code&gt; function. Many parameters
controlling the appearance of plots can be overridden by passing this function
to &lt;code&gt;plot()&lt;/code&gt; or setting the Theme as the current theme using &lt;code&gt;push_theme()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For instance, we can change the label and size label:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Gadfly.plot(x = rand(10), y = rand(10),
             Theme(major_label_font = &amp;quot;Hack&amp;quot;,
                   minor_label_font = &amp;quot;Hack&amp;quot;,
                   major_label_font_size = 16pt,
                   minor_label_font_size = 14pt,
                   background_color = &amp;quot;#bdbdbd&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;center&gt;
&lt;img src=&#34;https://cleytonfar.github.io/images/figure_posts/gadfly_plot6.svg&#34; height=&#34;500&#34; width=&#34;700&#34; /&gt;
&lt;/center&gt;
&lt;p&gt;There are a lot of options we can tweak in &lt;code&gt;Theme()&lt;/code&gt;. This is just the surface.
For the full list of options, see &lt;a href=&#34;http://tamasnagy.com/Gadfly.jl/man/themes.html&#34;&gt;this link&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;calling-ggplot2&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Calling ggplot2&lt;/h1&gt;
&lt;p&gt;The &lt;strong&gt;Plots&lt;/strong&gt; and &lt;strong&gt;Gadfly&lt;/strong&gt; package are the two main plotting packages for &lt;strong&gt;Julia&lt;/strong&gt;.
Each one have different characteristics and a syntax on their own.&lt;/p&gt;
&lt;p&gt;However, let’s say you have an &lt;strong&gt;R&lt;/strong&gt; background and you are very used to the wonderful
&lt;em&gt;ggplot2&lt;/em&gt; package and would rather not to learn another plotting system. Or it might
be the case that while you are still learning the &lt;strong&gt;Julia&lt;/strong&gt; plotting system you have to create
very well crafted plots for your report but you only know how to do it in &lt;em&gt;ggplot2&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;What if I told you there is a way to use &lt;strong&gt;Julia&lt;/strong&gt; and still make plots using &lt;em&gt;ggplot2&lt;/em&gt; package?
Well, in order to do that we will use the &lt;strong&gt;RCall&lt;/strong&gt; package. First of all, let’s install
this package:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Pkg.add(&amp;quot;RCall&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;RCall&lt;/strong&gt; is package with the aim of facilitating communication between
&lt;strong&gt;R&lt;/strong&gt; and &lt;strong&gt;Julia&lt;/strong&gt; languages and allows the user to call &lt;strong&gt;R&lt;/strong&gt; packages from within
&lt;strong&gt;Julia&lt;/strong&gt;, providing the best of both worlds.&lt;/p&gt;
&lt;p&gt;In order to call &lt;em&gt;ggplot2&lt;/em&gt; package from &lt;strong&gt;Julia&lt;/strong&gt;, we use the &lt;code&gt;@rlibrary&lt;/code&gt; syntax to
load the &lt;strong&gt;R&lt;/strong&gt; package. Then, we can use &lt;code&gt;R&#34;&#34;&lt;/code&gt; syntax to call the &lt;strong&gt;R&lt;/strong&gt; command:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;using RCall
@rlibrary ggplot2
gasoline = dataset(&amp;quot;Ecdat&amp;quot;, &amp;quot;Gasoline&amp;quot;);

## notice that we use $name_dataset inside R&amp;quot;&amp;quot; command.
R&amp;quot;ggplot($gasoline, aes(x = Year, y = LGasPCar, color = Country)) +
  geom_line() + 
  geom_point() + 
  ggthemes::theme_economist_white(gray_bg = F) +    
  theme(panel.grid.major = element_line(colour = &amp;#39;#d9d9d9&amp;#39;,
                                        size = rel(0.9),
                                        linetype=&amp;#39;dashed&amp;#39;),
        legend.position = &amp;#39;bottom&amp;#39;,
        legend.direction = &amp;#39;horizontal&amp;#39;,
        legend.box = &amp;#39;horizontal&amp;#39;,
        legend.key.size = unit(1, &amp;#39;cm&amp;#39;),
        plot.title = element_text(family= &amp;#39;AvantGarde&amp;#39;, hjust = 0.5),
        text = element_text(family =  &amp;#39;AvantGarde&amp;#39;),
        axis.title = element_text(size = 12),
        axis.text.x = element_text(angle = 0, hjust = 0.5),
        legend.text = element_text(size = 12),
        legend.title=element_text(face = &amp;#39;bold&amp;#39;, size = 12)) +
  labs(title = &amp;#39;Gas Consumption over the years&amp;#39;, x = &amp;#39;&amp;#39;, y = &amp;#39;&amp;#39;)&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://cleytonfar.github.io/posts/2019-03-20-using-julia-for-data-science-part-03_files/figure-html/unnamed-chunk-14-15.png&#34; width=&#34;50%&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;That’s it!!! Now, You do not need to leave &lt;strong&gt;Julia&lt;/strong&gt; in order to make your plots with &lt;em&gt;ggplot2&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusion&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;In this post we saw basic functionalities of the main packages from the &lt;strong&gt;Julia&lt;/strong&gt;
plotting system. &lt;strong&gt;Plots&lt;/strong&gt; and &lt;strong&gt;Gadfly&lt;/strong&gt; stand out as the major players when it comes
to plotting in &lt;strong&gt;Julia&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;Plots&lt;/strong&gt; package is not really a plotting package but rather an API to call other
plotting libraries using a common syntax. Its functionalities kind of resembles
the ones from the &lt;em&gt;base&lt;/em&gt; plotting system in &lt;strong&gt;R&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;On the other hand, the &lt;strong&gt;Gadfly&lt;/strong&gt; is an implementation of the “&lt;em&gt;grammar of graphics&lt;/em&gt;”
style once found in the already consolidated &lt;em&gt;ggplot2&lt;/em&gt; package from &lt;strong&gt;R&lt;/strong&gt;.
It resambles many of the functionalities found in &lt;em&gt;ggplot2&lt;/em&gt; and highly customizable.&lt;/p&gt;
&lt;p&gt;Which package is better depends on the case and, of course, in your preferences.
Personally, I am very satisfied with &lt;strong&gt;Gadfly&lt;/strong&gt; because of the similarities with
&lt;em&gt;ggplot2&lt;/em&gt;, but &lt;strong&gt;Plots&lt;/strong&gt; package offers some handy functionalities throught
recipes libraries, for instance &lt;strong&gt;StatsPlots&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;As an introduction to the topic, I hope this post helps you get a better understand
on how to make well crafted plots in &lt;strong&gt;Julia&lt;/strong&gt;. Have any additional comments or
suggestion, please feel free to let me know!!&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Using Julia for Data Science (Part 02)</title>
      <link>https://cleytonfar.github.io/posts/using-julia-for-data-science-part-02/</link>
      <pubDate>Wed, 20 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cleytonfar.github.io/posts/using-julia-for-data-science-part-02/</guid>
      <description>
&lt;script src=&#34;https://cleytonfar.github.io/rmarkdown-libs/kePrint/kePrint.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;In the &lt;a href=&#34;https://cleytonfar.github.io/posts/using-julia-for-data-science/&#34;&gt;previous post&lt;/a&gt;,
we talked about what is &lt;strong&gt;Julia&lt;/strong&gt;, how to install it and we have learned how to work
rightaway with tabular data. Now we are going to take one more step and learn new
tricks with the &lt;strong&gt;DataFramesMeta&lt;/strong&gt; package.
&lt;!-- Remember that in the first part of this series, I use the `@linq` command.  --&gt;&lt;/p&gt;
&lt;p&gt;The first thing that we need to do is to install the package.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;using Pkg
Pkg.add(&amp;quot;DataFramesMeta&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once it is installed, let’s get started!&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Important&lt;/strong&gt;: In this post I am using the current stable release (v1.1.0). For
those who are using the long-term support release (v1.0.3), all the code will run just
fine.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div id=&#34;introduction-to-dataframesmeta-package&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Introduction to DataFramesMeta package&lt;/h1&gt;
&lt;p&gt;The &lt;strong&gt;DataFramesMeta&lt;/strong&gt; is a package that provides a collection of metaprogramming
tools for &lt;strong&gt;DataFrames&lt;/strong&gt;. But you may be wondering why you should worry about
metaprogramming? This package
offers some &lt;em&gt;macros&lt;/em&gt; that can be used to improve performance and provide more
convenient syntax. But again, you might be asking: how is that useful?&lt;/p&gt;
&lt;p&gt;Ok ok ok. So, let’s consider the example used in the &lt;a href=&#34;https://cleytonfar.github.io/posts/using-julia-for-data-science/&#34;&gt;previous post&lt;/a&gt; where we
had some random dataset and we wanted the rows which &lt;em&gt;x1&lt;/em&gt; and &lt;em&gt;x2&lt;/em&gt; are
both greater than or equal to their average:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;using DataFrames
using Statistics
## Creating a random dataset with 10 rows and 5 columns:
foo = DataFrame(rand(10, 5));
## Creating the conditions:
cond1 = foo.x1 .&amp;gt;= mean(foo.x1);
cond2 = foo.x2 .&amp;gt;= mean(foo.x2);
## Subsetting:
foo[.&amp;amp;(cond1, cond2), :]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3×5 DataFrame
## │ Row │ x1       │ x2       │ x3       │ x4       │ x5       │
## │     │ Float64  │ Float64  │ Float64  │ Float64  │ Float64  │
## ├─────┼──────────┼──────────┼──────────┼──────────┼──────────┤
## │ 1   │ 0.646054 │ 0.809341 │ 0.594167 │ 0.950402 │ 0.860874 │
## │ 2   │ 0.907769 │ 0.777486 │ 0.645202 │ 0.168787 │ 0.988751 │
## │ 3   │ 0.479516 │ 0.921042 │ 0.240151 │ 0.55285  │ 0.488948 │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That is it!! But what if I told there is a way we could get the same result
typing much less code?&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;using DataFramesMeta
@where(foo, :x1 .&amp;gt;= mean(:x1), :x2 .&amp;gt;= mean(:x2))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3×5 DataFrame
## │ Row │ x1       │ x2       │ x3       │ x4       │ x5       │
## │     │ Float64  │ Float64  │ Float64  │ Float64  │ Float64  │
## ├─────┼──────────┼──────────┼──────────┼──────────┼──────────┤
## │ 1   │ 0.646054 │ 0.809341 │ 0.594167 │ 0.950402 │ 0.860874 │
## │ 2   │ 0.907769 │ 0.777486 │ 0.645202 │ 0.168787 │ 0.988751 │
## │ 3   │ 0.479516 │ 0.921042 │ 0.240151 │ 0.55285  │ 0.488948 │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Did you see that? Using the macro &lt;code&gt;@where&lt;/code&gt; we achieved the same result as before
with just one line of code. That’s what &lt;strong&gt;DataFramesMeta&lt;/strong&gt; package is all about:
a collection of “&lt;em&gt;functions&lt;/em&gt;” begining with @ that simplifies some tasks when
working with &lt;strong&gt;DataFrames&lt;/strong&gt;.&lt;/p&gt;
&lt;div id=&#34;main-features-of-dataframesmeta&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Main Features of DataFramesMeta:&lt;/h2&gt;
&lt;p&gt;In this post, we are going to explore what I considered to be the main tools of
the &lt;strong&gt;DataFramesMeta&lt;/strong&gt; package. For more detail, please refer to the official documentation.&lt;/p&gt;
&lt;div id=&#34;with-macro&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;code&gt;@with&lt;/code&gt; macro&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;@with&lt;/code&gt; is a macro expression that can be used with &lt;strong&gt;DataFrames&lt;/strong&gt; that allows reference
columns as &lt;strong&gt;symbols&lt;/strong&gt; in expressions. For those who are familiar with &lt;strong&gt;R&lt;/strong&gt; language,
it works similarly to the &lt;code&gt;with()&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;df = DataFrame(x = 1:3, y = [2, 1, 2])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3×2 DataFrame
## │ Row │ x     │ y     │
## │     │ Int64 │ Int64 │
## ├─────┼───────┼───────┤
## │ 1   │ 1     │ 2     │
## │ 2   │ 2     │ 1     │
## │ 3   │ 3     │ 2     │&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;x = [2, 1, 0];
## Taking the columm &amp;quot;y&amp;quot; from the df DataFrame and adding 1:
@with(df, :y .+ 1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3-element Array{Int64,1}:
##  3
##  2
##  3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;## Taking the column &amp;quot;x&amp;quot; from df and add it to the x variable:
@with(df, :x + x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3-element Array{Int64,1}:
##  3
##  3
##  3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Also, we can reference the column by an expression and wrapped in &lt;code&gt;cols()&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;colref = :x;
@with(df, cols(colref) .+ 1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3-element Array{Int64,1}:
##  2
##  3
##  4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The use of &lt;code&gt;cols()&lt;/code&gt; is very useful when we want to perform some task over a list
of column variables in a &lt;code&gt;for&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; loop.&lt;/p&gt;
&lt;p&gt;If an expression is wrapped in &lt;code&gt;^(expr)&lt;/code&gt;, then &lt;em&gt;expr&lt;/em&gt; gets passed through untouched:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;@with(df, df[:x .&amp;gt; 1, ^(:y)])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 2-element Array{Int64,1}:
##  1
##  2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Later, I’ll show how to perform this same task by piping some macros using the
pipe &lt;code&gt;|&amp;gt;&lt;/code&gt; symbol.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;where-macro&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;code&gt;@where&lt;/code&gt; macro&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;@where&lt;/code&gt; is used when we want to get subsets of &lt;strong&gt;DataFrames&lt;/strong&gt; according to
some criteria. It is similar to the &lt;code&gt;filter()&lt;/code&gt; function from &lt;em&gt;dplyr&lt;/em&gt; package
in &lt;strong&gt;R&lt;/strong&gt;:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;@where(df, :x .&amp;gt; 1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 2×2 DataFrame
## │ Row │ x     │ y     │
## │     │ Int64 │ Int64 │
## ├─────┼───────┼───────┤
## │ 1   │ 2     │ 1     │
## │ 2   │ 3     │ 2     │&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;@where(df, :x .&amp;gt; x, :y .== 1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 1×2 DataFrame
## │ Row │ x     │ y     │
## │     │ Int64 │ Int64 │
## ├─────┼───────┼───────┤
## │ 1   │ 2     │ 1     │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that if there is more than one condition inside &lt;code&gt;@where&lt;/code&gt;, the condition are
performed as &lt;em&gt;condition1&lt;/em&gt; &lt;strong&gt;AND&lt;/strong&gt; &lt;em&gt;condition2&lt;/em&gt;. But if you want an &lt;strong&gt;OR&lt;/strong&gt; condition to
be performed, we can use the &lt;code&gt;|()&lt;/code&gt; syntax:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;@where(df, .|(:x .&amp;gt; x, :y .== 1))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 2×2 DataFrame
## │ Row │ x     │ y     │
## │     │ Int64 │ Int64 │
## ├─────┼───────┼───────┤
## │ 1   │ 2     │ 1     │
## │ 2   │ 3     │ 2     │&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;select-macro&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;code&gt;@select&lt;/code&gt; macro&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;@select&lt;/code&gt; macro can be used to perform column selection in &lt;strong&gt;DataFrames&lt;/strong&gt;. Again,
if you are familiar with the &lt;em&gt;dplyr&lt;/em&gt; package in &lt;strong&gt;R&lt;/strong&gt;, it works similarly to the
&lt;code&gt;select()&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;## Select column x and return as a DataFrame:
@select(df, :x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3×1 DataFrame
## │ Row │ x     │
## │     │ Int64 │
## ├─────┼───────┤
## │ 1   │ 1     │
## │ 2   │ 2     │
## │ 3   │ 3     │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Moreover, we can also mutate variables using &lt;code&gt;@select&lt;/code&gt;. For instance, suppose that
we want the columns &lt;em&gt;x&lt;/em&gt;, &lt;em&gt;y&lt;/em&gt;, and a new column representing &lt;em&gt;x&lt;/em&gt; times &lt;em&gt;y&lt;/em&gt;:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;@select(df, :x, :y, x_y = :x .* :y)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3×3 DataFrame
## │ Row │ x     │ y     │ x_y   │
## │     │ Int64 │ Int64 │ Int64 │
## ├─────┼───────┼───────┼───────┤
## │ 1   │ 1     │ 2     │ 2     │
## │ 2   │ 2     │ 1     │ 2     │
## │ 3   │ 3     │ 2     │ 6     │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that the name of the new column is not referenced as symbol.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;transform-macro&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;code&gt;@transform&lt;/code&gt; macro&lt;/h3&gt;
&lt;p&gt;The &lt;strong&gt;DataFramesMeta&lt;/strong&gt; also has a specific macro to perform mutation.
&lt;code&gt;@transform&lt;/code&gt; is very useful when we want to add new columns based on keyword
argument:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;@transform(df, newColumn = :x .^ 2 + 2 .* :x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3×3 DataFrame
## │ Row │ x     │ y     │ newColumn │
## │     │ Int64 │ Int64 │ Int64     │
## ├─────┼───────┼───────┼───────────┤
## │ 1   │ 1     │ 2     │ 3         │
## │ 2   │ 2     │ 1     │ 8         │
## │ 3   │ 3     │ 2     │ 15        │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One more time, &lt;code&gt;@transform&lt;/code&gt; works similarly to the &lt;code&gt;mutate()&lt;/code&gt; function from
&lt;em&gt;dplyr&lt;/em&gt; package in &lt;strong&gt;R&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;orderby-macro&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;code&gt;@orderby&lt;/code&gt; macro&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;@orderby&lt;/code&gt; macro is used to sort the dataset according to a specific column.&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;using StatsBase # to use the sample() function
## unordered data set: shuffling the dataset
df = df[sample(1:nrow(df), nrow(df), replace = false), :]
## ordered data set:
@orderby(df, :x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3×2 DataFrame
## │ Row │ x     │ y     │
## │     │ Int64 │ Int64 │
## ├─────┼───────┼───────┤
## │ 1   │ 1     │ 2     │
## │ 2   │ 2     │ 1     │
## │ 3   │ 3     │ 2     │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By default, the sort will be performed in &lt;strong&gt;ascending&lt;/strong&gt; order. To sort
in &lt;strong&gt;descending&lt;/strong&gt; order, just add a &lt;em&gt;negative&lt;/em&gt; sign:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;@orderby(df, -:x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3×2 DataFrame
## │ Row │ x     │ y     │
## │     │ Int64 │ Int64 │
## ├─────┼───────┼───────┤
## │ 1   │ 3     │ 2     │
## │ 2   │ 2     │ 1     │
## │ 3   │ 1     │ 2     │&lt;/code&gt;&lt;/pre&gt;
&lt;!-- ### `@based_on` macro --&gt;
&lt;!-- `@based_on` macro works similarly to the `summarise()` function from *dplyr* package in **R**.  --&gt;
&lt;!-- To demontrate we are going to use the iris dataset.  --&gt;
&lt;!-- For example: Suppose that we want the average of variable *PetalWidth* by *SepalWidth*.  --&gt;
&lt;!-- First, we group the daset using the `groupby()` function using *SepalWidth* as key --&gt;
&lt;!-- and then apply the `@based_on` macro to calculate the average on each of these categories: --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- using RDatasets --&gt;
&lt;!-- iris = dataset(&#34;datasets&#34;, &#34;iris&#34;); --&gt;
&lt;!-- iris = groupby(iris, :SepalWidth); --&gt;
&lt;!-- @based_on(iris, avg = mean(:PetalWidth)) --&gt;
&lt;!-- ``` --&gt;
&lt;!-- One important feature to notice: `@based_on` only accepts key that are numeric. If you want to group by --&gt;
&lt;!-- variables that are categorical, you have to convert to numeric first. Otherwise  --&gt;
&lt;!-- `@based_on` will throw an error.  --&gt;
&lt;/div&gt;
&lt;div id=&#34;linq-macro&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;code&gt;@linq&lt;/code&gt; macro&lt;/h3&gt;
&lt;p&gt;For me, this is the most useful macro in this package. &lt;code&gt;@linq&lt;/code&gt; macro supports
chaining all of the functionality defined in other macros. In practice, it
means that we can chain a bunch of macro commands using the pipe &lt;code&gt;|&amp;gt;&lt;/code&gt; syntax,
but overcoming its limitations. What do I mean about limitations of the pipe symbol?
Take the following as an example:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;## This will not work:
df |&amp;gt;
    select(:x) |&amp;gt;
    transform(newColumn = :x .^2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When you run this chunk, &lt;strong&gt;Julia&lt;/strong&gt; will throw an error because it will not
recognize the &lt;code&gt;select&lt;/code&gt; macro, but also it will not figure it out how pipe the
&lt;em&gt;df&lt;/em&gt; dataset to the following functions. That’s when the &lt;code&gt;@linq&lt;/code&gt; macro is very
useful:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;## This will work:
@linq df |&amp;gt;
    select(:x) |&amp;gt;
    transform(newColumn = :x .^2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3×2 DataFrame
## │ Row │ x     │ newColumn │
## │     │ Int64 │ Int64     │
## ├─────┼───────┼───────────┤
## │ 1   │ 1     │ 1         │
## │ 2   │ 2     │ 4         │
## │ 3   │ 3     │ 9         │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As we can see, the use of the &lt;code&gt;@linq&lt;/code&gt; macro allows us to pipe the &lt;em&gt;df&lt;/em&gt; dataset
to the first macro, and then pipe the result of this to the following macro and
so on. Moreover, chaining the individual macros makes the code looks cleaner and
more obvious with less noise from @ symbols.&lt;/p&gt;
&lt;p&gt;Previously, we performed an operation using the &lt;code&gt;@with&lt;/code&gt; macro where we subset
the rows with &lt;em&gt;x&lt;/em&gt; greater than 1 and take only the column &lt;em&gt;y&lt;/em&gt;:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;@with(df, df[:x .&amp;gt; 1, ^(:y)])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 2-element Array{Int64,1}:
##  1
##  2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We could get the same result using &lt;code&gt;@linq&lt;/code&gt; and &lt;code&gt;|&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;@linq df |&amp;gt;
    where(:x .&amp;gt; 1) |&amp;gt;
    select(:y)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 2×1 DataFrame
## │ Row │ y     │
## │     │ Int64 │
## ├─────┼───────┤
## │ 1   │ 1     │
## │ 2   │ 2     │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Moreover, you can not only use &lt;code&gt;@linq&lt;/code&gt; to chain macros, but also with any
function. For example, we can pipe a dataset to see the first 5 rows as well as
to the &lt;code&gt;describe()&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;@linq foo |&amp;gt; 
    first(5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 5×5 DataFrame
## │ Row │ x1        │ x2        │ x3       │ x4       │ x5       │
## │     │ Float64   │ Float64   │ Float64  │ Float64  │ Float64  │
## ├─────┼───────────┼───────────┼──────────┼──────────┼──────────┤
## │ 1   │ 0.0300364 │ 0.646456  │ 0.106503 │ 0.123473 │ 0.909045 │
## │ 2   │ 0.646054  │ 0.809341  │ 0.594167 │ 0.950402 │ 0.860874 │
## │ 3   │ 0.139928  │ 0.319494  │ 0.661613 │ 0.879849 │ 0.310157 │
## │ 4   │ 0.907769  │ 0.777486  │ 0.645202 │ 0.168787 │ 0.988751 │
## │ 5   │ 0.300036  │ 0.0099053 │ 0.443635 │ 0.339335 │ 0.295239 │&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;## Default behavior will omitt some columns:
@linq foo |&amp;gt; 
    describe&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 5×8 DataFrame. Omitted printing of 2 columns
## │ Row │ variable │ mean     │ min       │ median   │ max      │ nunique │
## │     │ Symbol   │ Float64  │ Float64   │ Float64  │ Float64  │ Nothing │
## ├─────┼──────────┼──────────┼───────────┼──────────┼──────────┼─────────┤
## │ 1   │ x1       │ 0.476897 │ 0.0300364 │ 0.562785 │ 0.907769 │         │
## │ 2   │ x2       │ 0.542662 │ 0.0099053 │ 0.574104 │ 0.943536 │         │
## │ 3   │ x3       │ 0.53466  │ 0.106503  │ 0.608272 │ 0.934401 │         │
## │ 4   │ x4       │ 0.578453 │ 0.123473  │ 0.670891 │ 0.950402 │         │
## │ 5   │ x5       │ 0.659181 │ 0.122184  │ 0.784656 │ 0.988751 │         │&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;## This will show all columns:
@linq foo |&amp;gt; 
    describe |&amp;gt; 
    show(allcols = true)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 5×8 DataFrame
## │ Row │ variable │ mean     │ min       │ median   │ max      │ nunique │
## │     │ Symbol   │ Float64  │ Float64   │ Float64  │ Float64  │ Nothing │
## ├─────┼──────────┼──────────┼───────────┼──────────┼──────────┼─────────┤
## │ 1   │ x1       │ 0.476897 │ 0.0300364 │ 0.562785 │ 0.907769 │         │
## │ 2   │ x2       │ 0.542662 │ 0.0099053 │ 0.574104 │ 0.943536 │         │
## │ 3   │ x3       │ 0.53466  │ 0.106503  │ 0.608272 │ 0.934401 │         │
## │ 4   │ x4       │ 0.578453 │ 0.123473  │ 0.670891 │ 0.950402 │         │
## │ 5   │ x5       │ 0.659181 │ 0.122184  │ 0.784656 │ 0.988751 │         │
## 
## │ Row │ nmissing │ eltype   │
## │     │ Nothing  │ DataType │
## ├─────┼──────────┼──────────┤
## │ 1   │          │ Float64  │
## │ 2   │          │ Float64  │
## │ 3   │          │ Float64  │
## │ 4   │          │ Float64  │
## │ 5   │          │ Float64  │&lt;/code&gt;&lt;/pre&gt;
&lt;!-- We can use `@linq` to pipe a data set to plot a scatter plot: --&gt;
&lt;!-- ```{julia, results = &#34;asis&#34;} --&gt;
&lt;!-- using Gadfly --&gt;
&lt;!-- @linq iris |&gt; --&gt;
&lt;!--     plot(x= :SepalLength, y = :SepalWidth, color = :Species, Geom.point) --&gt;
&lt;!-- ``` --&gt;
&lt;!-- For now, take the last command for granted. Plots is the subject for another post.  --&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusion&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;The &lt;strong&gt;DataFramesMeta&lt;/strong&gt; package presents a collection of useful macros that can be used to
perform data wrangling and make our code cleaner. As we saw, some of these macros
behave similarly to functions commonly used in &lt;strong&gt;R&lt;/strong&gt;. Also, the use
of the pipe operator &lt;code&gt;|&amp;gt;&lt;/code&gt; plus the &lt;code&gt;@linq&lt;/code&gt; macro makes the experience even more
alike to the &lt;code&gt;%&amp;gt;%&lt;/code&gt; operator from &lt;em&gt;maggrittr&lt;/em&gt; package in &lt;strong&gt;R&lt;/strong&gt;. Hence, if you come (like me) from a
&lt;strong&gt;R&lt;/strong&gt; background, &lt;strong&gt;Julia&lt;/strong&gt; can become a lot easier to learn. The following table
summarizes the equivalence among functions used in this post between the two
languages:&lt;/p&gt;
&lt;table class=&#34;table table-striped&#34; style=&#34;width: auto !important; margin-left: auto; margin-right: auto;&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
Julia
&lt;/th&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
R
&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
&lt;span class=&#34;citation&#34;&gt;@with&lt;/span&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
with()
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
&lt;span class=&#34;citation&#34;&gt;@select&lt;/span&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
select()
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
&lt;span class=&#34;citation&#34;&gt;@where&lt;/span&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
filter()
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
&lt;span class=&#34;citation&#34;&gt;@transform&lt;/span&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
mutate()
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
&lt;span class=&#34;citation&#34;&gt;@orderby&lt;/span&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
arrange()/order()
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
&lt;span class=&#34;citation&#34;&gt;@linq&lt;/span&gt; + |&amp;gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
%&amp;gt;%
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Using Julia for Data Science </title>
      <link>https://cleytonfar.github.io/posts/using-julia-for-data-science/</link>
      <pubDate>Mon, 11 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cleytonfar.github.io/posts/using-julia-for-data-science/</guid>
      <description>


&lt;p&gt;In recent years, data science has become a huge attractive field with the
profession of data scientist topping the list of the best jobs in America.
And with all the hype that the field produces, one might ask: what does it take do
be a data scientist?&lt;/p&gt;
&lt;p&gt;Well… that’s a good question. First of all, there are a lot of requirements. But one
of the most important ones is to learn how to work with data sets. And I am not
talking about playing with spreadsheets. I am talking about working with some
real programming language to get the job done with any datasets, no matter how
huge it is.&lt;/p&gt;
&lt;p&gt;Hence, this post is the first part of a series about working with tabular data
with the Julia programming language. Of course, the aim of this post is not only
to give you a quick introduction to the language, but also present to you how
you can easily install and work rightaway with datasets with Julia.&lt;/p&gt;
&lt;div id=&#34;why-julia&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Why Julia?&lt;/h1&gt;
&lt;p&gt;Glad you asked! Julia is a high level programming language released in 2012 by a
team of MIT researchers. Since its beginning, the aim was to solve the so called
two-language programing problem: easy to use functionalities of interpretable languages
(Python, R, Matlab) vs high performance of compiled languages (C, C++, Fortran).
According to its creators:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We want a language that’s open source, with a liberal license.
We want the speed of C with the dynamism of Ruby.
We want a language that’s homoiconic, with true macros like Lisp, but with obvious,
familiar mathematical notation like Matlab. We want something as usable for
general programming as Python, as easy for statistics as R, as natural for string
processing as Perl, as powerful for linear algebra as Matlab, as good at gluing
programs together as the shell.
Something that is dirt simple to learn, yet keeps the most serious hackers happy.
We want it interactive and we want it compiled. — &lt;a href=&#34;https://julialang.org/&#34; target=&#34;_blank&#34;&gt;julialang.org&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Hence, Julia was born. Combining the JIT (Just In Time) compiler and
Julia’s multiple-dispatch system plus the fact that its codebase is written
entirely in native language, Julia gives birth to the popular phrase in the
community:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“Walks like Python, runs like C.”&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;installing-julia&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Installing Julia&lt;/h1&gt;
&lt;p&gt;To play around with Julia there are some options. One obvious way is to download
the official binaries from the &lt;a href=&#34;https://julialang.org/downloads/&#34;&gt;site&lt;/a&gt; for your
specific plataform (Windows, macOS, Linux, etc). At the
time of this writting, the &lt;strong&gt;Current stable release&lt;/strong&gt; is &lt;strong&gt;v1.1.0&lt;/strong&gt; and the
&lt;strong&gt;Long-term support release&lt;/strong&gt; is &lt;strong&gt;v1.0.3&lt;/strong&gt;. Once you downloaded and execute
the binaries, you will see the following window:&lt;/p&gt;
&lt;center&gt;
&lt;img src=&#34;https://cleytonfar.github.io/posts/julia.png&#34; width=&#34;500&#34; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;Another options is to use Julia in the browser on &lt;a href=&#34;https://juliabox.com/&#34;&gt;JuliaBox.com&lt;/a&gt;
with Jupyter notebooks. No installation is required – just point your browser
there, login and start playing around.&lt;/p&gt;
&lt;div id=&#34;installing-packages&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Installing Packages&lt;/h2&gt;
&lt;p&gt;All the package management in Julia is performed by the &lt;strong&gt;Pkg&lt;/strong&gt; package. To
install a given package we use &lt;code&gt;Pkg.add(&#34;package_name&#34;)&lt;/code&gt;. In this tutorial we
are going to use some packages that are not pre-installed with Julia. To install
them, do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;using Pkg
Pkg.add(&amp;quot;DataFrames&amp;quot;)
Pkg.add(&amp;quot;DataFramesMeta&amp;quot;)
Pkg.add(&amp;quot;CSV&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We installed three packages: &lt;strong&gt;DataFrames&lt;/strong&gt; (which is the subject of this post),
&lt;strong&gt;DataFramesMeta&lt;/strong&gt; (we will use some of its functionalities) and &lt;strong&gt;CSV&lt;/strong&gt; (to read
and write CSV files).&lt;/p&gt;
&lt;p&gt;Of course there is more about package management in Julia than I just showed.
A great introduction is presented in this &lt;a href=&#34;https://www.youtube.com/watch?v=76KL8aSz0Sg&#34;&gt;video&lt;/a&gt; by Jane
Harriman. For more advanced usage, please refer to the &lt;a href=&#34;https://docs.julialang.org/en/v1/stdlib/Pkg/index.html&#34;&gt;official documentation&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;introduction-to-dataframes-in-julia&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Introduction to DataFrames in Julia&lt;/h1&gt;
&lt;p&gt;In Julia, tablular data is handled using the &lt;strong&gt;DataFrames&lt;/strong&gt; package. Other packages
are commonly used to read/write data into/from Julia such as &lt;strong&gt;CSV&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;A data frame is created using the &lt;code&gt;DataFrame()&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;using DataFrames 
foo = DataFrame();
foo &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 0×0 DataFrame&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To use the functionalities of the package, let’s create some random data. I will
use the &lt;code&gt;rand()&lt;/code&gt; function to generate random numbers to create an array 100 x 10
and convert it to a data frame:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;foo = DataFrame(rand(100, 10));
foo &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 100×10 DataFrame. Omitted printing of 4 columns
## │ Row │ x1         │ x2       │ x3        │ x4       │ x5        │ x6        │
## │     │ Float64    │ Float64  │ Float64   │ Float64  │ Float64   │ Float64   │
## ├─────┼────────────┼──────────┼───────────┼──────────┼───────────┼───────────┤
## │ 1   │ 0.28215    │ 0.953277 │ 0.0345734 │ 0.380847 │ 0.831492  │ 0.788669  │
## │ 2   │ 0.457433   │ 0.357775 │ 0.45568   │ 0.374921 │ 0.57703   │ 0.0701288 │
## │ 3   │ 0.762276   │ 0.573336 │ 0.0349542 │ 0.658953 │ 0.4545    │ 0.919184  │
## │ 4   │ 0.177085   │ 0.895052 │ 0.714325  │ 0.43383  │ 0.839534  │ 0.509621  │
## │ 5   │ 0.178866   │ 0.43665  │ 0.516935  │ 0.45325  │ 0.43443   │ 0.807217  │
## │ 6   │ 0.00338195 │ 0.516974 │ 0.287649  │ 0.569926 │ 0.463839  │ 0.626427  │
## │ 7   │ 0.0306091  │ 0.171283 │ 0.676435  │ 0.651781 │ 0.0673628 │ 0.759895  │
## ⋮
## │ 93  │ 0.842047   │ 0.156874 │ 0.972108  │ 0.121516 │ 0.824025  │ 0.319138  │
## │ 94  │ 0.985372   │ 0.482079 │ 0.0765152 │ 0.818235 │ 0.546266  │ 0.561243  │
## │ 95  │ 0.42654    │ 0.17668  │ 0.835386  │ 0.065945 │ 0.309747  │ 0.0293535 │
## │ 96  │ 0.889303   │ 0.66188  │ 0.971318  │ 0.547523 │ 0.170187  │ 0.987903  │
## │ 97  │ 0.0541391  │ 0.436057 │ 0.434473  │ 0.978984 │ 0.394627  │ 0.395319  │
## │ 98  │ 0.150143   │ 0.748007 │ 0.984081  │ 0.850741 │ 0.310097  │ 0.090252  │
## │ 99  │ 0.488791   │ 0.290897 │ 0.412977  │ 0.586124 │ 0.0231072 │ 0.597277  │
## │ 100 │ 0.577735   │ 0.969342 │ 0.525567  │ 0.19326  │ 0.491485  │ 0.622967  │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Maybe you have noticed the “;” at the end of a command. It turns out that in Julia,
contrary to many other languages, &lt;strong&gt;everything is an expression&lt;/strong&gt;, so it will return
a result. Hence, to &lt;em&gt;turn off&lt;/em&gt; this return, we must include the “;” at the end of
each command.&lt;/p&gt;
&lt;p&gt;To get the dimension of a data frame, we can use the &lt;code&gt;size()&lt;/code&gt; function. Also,
similarly to &lt;strong&gt;R&lt;/strong&gt; programming language, &lt;code&gt;nrow()&lt;/code&gt; and &lt;code&gt;ncol()&lt;/code&gt; are available to
get the number of rows and columns, respectively:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;size(foo)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## (100, 10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;nrow(foo)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 100&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;ncol(foo)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 10&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another basic task when working with datasets is to to get the names of each
variable contained in the table. We use the &lt;code&gt;names()&lt;/code&gt; function to get the column
names:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;names(foo)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 10-element Array{Symbol,1}:
##  :x1 
##  :x2 
##  :x3 
##  :x4 
##  :x5 
##  :x6 
##  :x7 
##  :x8 
##  :x9 
##  :x10&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To get a summary of the dataset in general, we can use the function &lt;code&gt;describe()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;describe(foo)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 10×8 DataFrame. Omitted printing of 2 columns
## │ Row │ variable │ mean     │ min         │ median   │ max      │ nunique │
## │     │ Symbol   │ Float64  │ Float64     │ Float64  │ Float64  │ Nothing │
## ├─────┼──────────┼──────────┼─────────────┼──────────┼──────────┼─────────┤
## │ 1   │ x1       │ 0.500482 │ 0.00338195  │ 0.541717 │ 0.996275 │         │
## │ 2   │ x2       │ 0.468118 │ 0.000194948 │ 0.436354 │ 0.987632 │         │
## │ 3   │ x3       │ 0.488071 │ 0.0158319   │ 0.471417 │ 0.984081 │         │
## │ 4   │ x4       │ 0.490187 │ 0.000430076 │ 0.496567 │ 0.978984 │         │
## │ 5   │ x5       │ 0.47641  │ 0.00770478  │ 0.477222 │ 0.993422 │         │
## │ 6   │ x6       │ 0.492461 │ 0.0216821   │ 0.486359 │ 0.987903 │         │
## │ 7   │ x7       │ 0.482229 │ 0.0018443   │ 0.432912 │ 0.985825 │         │
## │ 8   │ x8       │ 0.471235 │ 0.000107069 │ 0.45074  │ 0.990403 │         │
## │ 9   │ x9       │ 0.513075 │ 0.000820407 │ 0.519066 │ 0.997633 │         │
## │ 10  │ x10      │ 0.45141  │ 0.00149638  │ 0.434137 │ 0.981571 │         │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that there is a message indicating the omission of some columns. This is the
default behavior of Julia. To avoid this feature, we use the &lt;code&gt;show()&lt;/code&gt; function
as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show(describe(foo), allcols = true)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;manipulating-rows&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Manipulating Rows:&lt;/h2&gt;
&lt;p&gt;Subset rows in Julia can be a little odd in the beginning, but once you get used to, it becomes
more logical. For example, suppose we want the rows where &lt;em&gt;x1&lt;/em&gt; is above its average.
We could this as follows:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;## Loading the Statistics package:
using Statistics
## Creating the conditional:
cond01 = foo[:x1] .&amp;gt;= mean(foo[:x1]);
## Subsetting the rows:
foo[cond01, :] &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 53×10 DataFrame. Omitted printing of 4 columns
## │ Row │ x1       │ x2       │ x3        │ x4       │ x5       │ x6       │
## │     │ Float64  │ Float64  │ Float64   │ Float64  │ Float64  │ Float64  │
## ├─────┼──────────┼──────────┼───────────┼──────────┼──────────┼──────────┤
## │ 1   │ 0.762276 │ 0.573336 │ 0.0349542 │ 0.658953 │ 0.4545   │ 0.919184 │
## │ 2   │ 0.570813 │ 0.372602 │ 0.285062  │ 0.627526 │ 0.865243 │ 0.810667 │
## │ 3   │ 0.71528  │ 0.59901  │ 0.373738  │ 0.181532 │ 0.981097 │ 0.840872 │
## │ 4   │ 0.59782  │ 0.334053 │ 0.143347  │ 0.320254 │ 0.296799 │ 0.605662 │
## │ 5   │ 0.828555 │ 0.907726 │ 0.905068  │ 0.670738 │ 0.917006 │ 0.774667 │
## │ 6   │ 0.963461 │ 0.211709 │ 0.0809192 │ 0.424117 │ 0.731419 │ 0.789158 │
## │ 7   │ 0.868988 │ 0.874534 │ 0.101108  │ 0.265043 │ 0.461592 │ 0.734996 │
## ⋮
## │ 46  │ 0.955462 │ 0.265106 │ 0.242147  │ 0.400818 │ 0.96047  │ 0.250868 │
## │ 47  │ 0.710372 │ 0.652336 │ 0.809856  │ 0.419962 │ 0.514623 │ 0.928958 │
## │ 48  │ 0.728981 │ 0.797295 │ 0.161475  │ 0.97124  │ 0.288903 │ 0.925466 │
## │ 49  │ 0.683366 │ 0.401062 │ 0.471624  │ 0.596489 │ 0.21934  │ 0.897484 │
## │ 50  │ 0.842047 │ 0.156874 │ 0.972108  │ 0.121516 │ 0.824025 │ 0.319138 │
## │ 51  │ 0.985372 │ 0.482079 │ 0.0765152 │ 0.818235 │ 0.546266 │ 0.561243 │
## │ 52  │ 0.889303 │ 0.66188  │ 0.971318  │ 0.547523 │ 0.170187 │ 0.987903 │
## │ 53  │ 0.577735 │ 0.969342 │ 0.525567  │ 0.19326  │ 0.491485 │ 0.622967 │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What if we want two conditionals? For example, we want the same condition as before
and/or the rows where &lt;em&gt;x2&lt;/em&gt; is greater than or equal its average? Now things
become trickier. Let’s check how we could do this:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;## Creating the second conditional:
cond02 = foo[:x2] .&amp;gt;= mean(foo[:x2]);
## Subsetting cond01 AND cond02:
foo[.&amp;amp;(cond01, cond02), :]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 27×10 DataFrame. Omitted printing of 4 columns
## │ Row │ x1       │ x2       │ x3        │ x4          │ x5       │ x6        │
## │     │ Float64  │ Float64  │ Float64   │ Float64     │ Float64  │ Float64   │
## ├─────┼──────────┼──────────┼───────────┼─────────────┼──────────┼───────────┤
## │ 1   │ 0.762276 │ 0.573336 │ 0.0349542 │ 0.658953    │ 0.4545   │ 0.919184  │
## │ 2   │ 0.71528  │ 0.59901  │ 0.373738  │ 0.181532    │ 0.981097 │ 0.840872  │
## │ 3   │ 0.828555 │ 0.907726 │ 0.905068  │ 0.670738    │ 0.917006 │ 0.774667  │
## │ 4   │ 0.868988 │ 0.874534 │ 0.101108  │ 0.265043    │ 0.461592 │ 0.734996  │
## │ 5   │ 0.567459 │ 0.565523 │ 0.710532  │ 0.0737811   │ 0.830622 │ 0.156976  │
## │ 6   │ 0.783998 │ 0.846182 │ 0.313373  │ 0.00634844  │ 0.045971 │ 0.444253  │
## │ 7   │ 0.811741 │ 0.971697 │ 0.508143  │ 0.924085    │ 0.44882  │ 0.0837864 │
## ⋮
## │ 20  │ 0.935721 │ 0.491311 │ 0.291639  │ 0.237592    │ 0.733159 │ 0.179683  │
## │ 21  │ 0.736076 │ 0.972862 │ 0.185572  │ 0.000879393 │ 0.901568 │ 0.363683  │
## │ 22  │ 0.639908 │ 0.839229 │ 0.202708  │ 0.175168    │ 0.244653 │ 0.819152  │
## │ 23  │ 0.710372 │ 0.652336 │ 0.809856  │ 0.419962    │ 0.514623 │ 0.928958  │
## │ 24  │ 0.728981 │ 0.797295 │ 0.161475  │ 0.97124     │ 0.288903 │ 0.925466  │
## │ 25  │ 0.985372 │ 0.482079 │ 0.0765152 │ 0.818235    │ 0.546266 │ 0.561243  │
## │ 26  │ 0.889303 │ 0.66188  │ 0.971318  │ 0.547523    │ 0.170187 │ 0.987903  │
## │ 27  │ 0.577735 │ 0.969342 │ 0.525567  │ 0.19326     │ 0.491485 │ 0.622967  │&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;## Subsetting cond01 OR cond02:
foo[.|(cond01, cond02), :]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 73×10 DataFrame. Omitted printing of 4 columns
## │ Row │ x1         │ x2       │ x3        │ x4       │ x5        │ x6       │
## │     │ Float64    │ Float64  │ Float64   │ Float64  │ Float64   │ Float64  │
## ├─────┼────────────┼──────────┼───────────┼──────────┼───────────┼──────────┤
## │ 1   │ 0.28215    │ 0.953277 │ 0.0345734 │ 0.380847 │ 0.831492  │ 0.788669 │
## │ 2   │ 0.762276   │ 0.573336 │ 0.0349542 │ 0.658953 │ 0.4545    │ 0.919184 │
## │ 3   │ 0.177085   │ 0.895052 │ 0.714325  │ 0.43383  │ 0.839534  │ 0.509621 │
## │ 4   │ 0.00338195 │ 0.516974 │ 0.287649  │ 0.569926 │ 0.463839  │ 0.626427 │
## │ 5   │ 0.570813   │ 0.372602 │ 0.285062  │ 0.627526 │ 0.865243  │ 0.810667 │
## │ 6   │ 0.71528    │ 0.59901  │ 0.373738  │ 0.181532 │ 0.981097  │ 0.840872 │
## │ 7   │ 0.59782    │ 0.334053 │ 0.143347  │ 0.320254 │ 0.296799  │ 0.605662 │
## ⋮
## │ 66  │ 0.0228222  │ 0.751965 │ 0.633983  │ 0.497977 │ 0.0428559 │ 0.830088 │
## │ 67  │ 0.683366   │ 0.401062 │ 0.471624  │ 0.596489 │ 0.21934   │ 0.897484 │
## │ 68  │ 0.0686648  │ 0.747845 │ 0.443056  │ 0.201244 │ 0.76253   │ 0.510496 │
## │ 69  │ 0.842047   │ 0.156874 │ 0.972108  │ 0.121516 │ 0.824025  │ 0.319138 │
## │ 70  │ 0.985372   │ 0.482079 │ 0.0765152 │ 0.818235 │ 0.546266  │ 0.561243 │
## │ 71  │ 0.889303   │ 0.66188  │ 0.971318  │ 0.547523 │ 0.170187  │ 0.987903 │
## │ 72  │ 0.150143   │ 0.748007 │ 0.984081  │ 0.850741 │ 0.310097  │ 0.090252 │
## │ 73  │ 0.577735   │ 0.969342 │ 0.525567  │ 0.19326  │ 0.491485  │ 0.622967 │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In Julia, instead of the syntax &lt;em&gt;condition1 &amp;amp; condition2&lt;/em&gt;, which is more common in
other programming languages, we use &lt;code&gt;&amp;amp;(condition1, condition2)&lt;/code&gt; or
&lt;code&gt;|(condition1, condition2)&lt;/code&gt; operators to perform multiple conditional
filtering.&lt;/p&gt;
&lt;p&gt;Now, let’s say you have a DataFrame and you want to &lt;strong&gt;append&lt;/strong&gt; rows to it.
There are a couple of ways of doing data. The first one is to use the &lt;code&gt;[data1; data2]&lt;/code&gt;
syntax:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;## Creating a DataFrame with 3 rows and 5 columns:
x = DataFrame(rand(3, 5));
## Let&amp;#39;s add another line using [dataset1; dataset2] syntax:
[ x ; DataFrame(rand(1, 5)) ]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 4×5 DataFrame
## │ Row │ x1       │ x2       │ x3       │ x4        │ x5       │
## │     │ Float64  │ Float64  │ Float64  │ Float64   │ Float64  │
## ├─────┼──────────┼──────────┼──────────┼───────────┼──────────┤
## │ 1   │ 0.91107  │ 0.823164 │ 0.832881 │ 0.0929049 │ 0.727934 │
## │ 2   │ 0.336336 │ 0.227813 │ 0.466649 │ 0.477715  │ 0.670853 │
## │ 3   │ 0.202198 │ 0.302405 │ 0.982715 │ 0.534741  │ 0.240536 │
## │ 4   │ 0.35228  │ 0.93864  │ 0.302848 │ 0.590661  │ 0.260018 │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We could get the same result using the &lt;code&gt;vcat()&lt;/code&gt; function. According to the
documentation, &lt;code&gt;vcat()&lt;/code&gt; performs &lt;em&gt;concatenation along dimension 1&lt;/em&gt;, which means
it will concatenate rows. The syntax would be:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## taking the first 2 lines and append with the third one:
vcat(x[1:2, :] , x[3, :])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another way to do that is using the function &lt;code&gt;append!()&lt;/code&gt;. This function will append
a new row to the last row in a given DataFrame. Note that the column names &lt;strong&gt;must&lt;/strong&gt;
match exactly.&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;## Column names matches
append!(x, DataFrame(rand(1, 5)))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 4×5 DataFrame
## │ Row │ x1       │ x2       │ x3       │ x4        │ x5       │
## │     │ Float64  │ Float64  │ Float64  │ Float64   │ Float64  │
## ├─────┼──────────┼──────────┼──────────┼───────────┼──────────┤
## │ 1   │ 0.91107  │ 0.823164 │ 0.832881 │ 0.0929049 │ 0.727934 │
## │ 2   │ 0.336336 │ 0.227813 │ 0.466649 │ 0.477715  │ 0.670853 │
## │ 3   │ 0.202198 │ 0.302405 │ 0.982715 │ 0.534741  │ 0.240536 │
## │ 4   │ 0.850252 │ 0.988636 │ 0.648322 │ 0.852869  │ 0.704921 │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that if the column names between two DataFrames do not match , the &lt;code&gt;append!()&lt;/code&gt;
function is going to throw an error. Although this kind of behavior is important
when we want to control for possible side effects, we might also prefer to not worry about
this and “&lt;em&gt;force&lt;/em&gt;” the append procedure. In order to do this we can make use of
the &lt;code&gt;push!()&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;## providing an Array:
push!(x, rand(ncol(x)))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 5×5 DataFrame
## │ Row │ x1       │ x2       │ x3       │ x4        │ x5       │
## │     │ Float64  │ Float64  │ Float64  │ Float64   │ Float64  │
## ├─────┼──────────┼──────────┼──────────┼───────────┼──────────┤
## │ 1   │ 0.91107  │ 0.823164 │ 0.832881 │ 0.0929049 │ 0.727934 │
## │ 2   │ 0.336336 │ 0.227813 │ 0.466649 │ 0.477715  │ 0.670853 │
## │ 3   │ 0.202198 │ 0.302405 │ 0.982715 │ 0.534741  │ 0.240536 │
## │ 4   │ 0.850252 │ 0.988636 │ 0.648322 │ 0.852869  │ 0.704921 │
## │ 5   │ 0.283413 │ 0.860327 │ 0.193691 │ 0.820888  │ 0.700506 │&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;## providing an dictionary:
push!(x, Dict(:x1 =&amp;gt; rand(),
              :x2 =&amp;gt; rand(),
              :x3 =&amp;gt; rand(),
              :x4 =&amp;gt; rand(),
              :x5 =&amp;gt; rand()))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 6×5 DataFrame
## │ Row │ x1       │ x2       │ x3       │ x4        │ x5       │
## │     │ Float64  │ Float64  │ Float64  │ Float64   │ Float64  │
## ├─────┼──────────┼──────────┼──────────┼───────────┼──────────┤
## │ 1   │ 0.91107  │ 0.823164 │ 0.832881 │ 0.0929049 │ 0.727934 │
## │ 2   │ 0.336336 │ 0.227813 │ 0.466649 │ 0.477715  │ 0.670853 │
## │ 3   │ 0.202198 │ 0.302405 │ 0.982715 │ 0.534741  │ 0.240536 │
## │ 4   │ 0.850252 │ 0.988636 │ 0.648322 │ 0.852869  │ 0.704921 │
## │ 5   │ 0.283413 │ 0.860327 │ 0.193691 │ 0.820888  │ 0.700506 │
## │ 6   │ 0.850845 │ 0.372089 │ 0.15189  │ 0.854041  │ 0.552215 │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As we can see, this function also accepts that we give a dictionary or an array
to append to a DataFrame.&lt;/p&gt;
&lt;p&gt;So, there are at least 4 methods to add rows to a DataFrame. Which one to use?
Let’s see how fast it is each function:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;using BenchmarkTools
@btime [x ; DataFrame(rand(1, 5))];
@btime vcat(x, DataFrame(rand(1, 5)));
@btime append!(x, DataFrame(rand(1, 5)));
@btime push!(x, rand(1, 5));&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;manipulating-columns&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Manipulating Columns:&lt;/h2&gt;
&lt;p&gt;One of the first things we would want to do when working with a dataset is selecting
some columns. In Julia, the syntax of selecting columns in DataFrames is similar to the one
used in &lt;em&gt;Matlab/Octave&lt;/em&gt;. For instance, we can make use of the &lt;strong&gt;“:”&lt;/strong&gt; symbol to represent
that we want all columns (or all rows) and/or a sequence of them:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;## Taking all rows of the first 2 columns:
foo[:, 1:2]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 100×2 DataFrame
## │ Row │ x1         │ x2       │
## │     │ Float64    │ Float64  │
## ├─────┼────────────┼──────────┤
## │ 1   │ 0.28215    │ 0.953277 │
## │ 2   │ 0.457433   │ 0.357775 │
## │ 3   │ 0.762276   │ 0.573336 │
## │ 4   │ 0.177085   │ 0.895052 │
## │ 5   │ 0.178866   │ 0.43665  │
## │ 6   │ 0.00338195 │ 0.516974 │
## │ 7   │ 0.0306091  │ 0.171283 │
## ⋮
## │ 93  │ 0.842047   │ 0.156874 │
## │ 94  │ 0.985372   │ 0.482079 │
## │ 95  │ 0.42654    │ 0.17668  │
## │ 96  │ 0.889303   │ 0.66188  │
## │ 97  │ 0.0541391  │ 0.436057 │
## │ 98  │ 0.150143   │ 0.748007 │
## │ 99  │ 0.488791   │ 0.290897 │
## │ 100 │ 0.577735   │ 0.969342 │&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;## Taking the first 10 rows of all columns:
foo[1:10, :]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 10×10 DataFrame. Omitted printing of 4 columns
## │ Row │ x1         │ x2       │ x3        │ x4       │ x5        │ x6        │
## │     │ Float64    │ Float64  │ Float64   │ Float64  │ Float64   │ Float64   │
## ├─────┼────────────┼──────────┼───────────┼──────────┼───────────┼───────────┤
## │ 1   │ 0.28215    │ 0.953277 │ 0.0345734 │ 0.380847 │ 0.831492  │ 0.788669  │
## │ 2   │ 0.457433   │ 0.357775 │ 0.45568   │ 0.374921 │ 0.57703   │ 0.0701288 │
## │ 3   │ 0.762276   │ 0.573336 │ 0.0349542 │ 0.658953 │ 0.4545    │ 0.919184  │
## │ 4   │ 0.177085   │ 0.895052 │ 0.714325  │ 0.43383  │ 0.839534  │ 0.509621  │
## │ 5   │ 0.178866   │ 0.43665  │ 0.516935  │ 0.45325  │ 0.43443   │ 0.807217  │
## │ 6   │ 0.00338195 │ 0.516974 │ 0.287649  │ 0.569926 │ 0.463839  │ 0.626427  │
## │ 7   │ 0.0306091  │ 0.171283 │ 0.676435  │ 0.651781 │ 0.0673628 │ 0.759895  │
## │ 8   │ 0.570813   │ 0.372602 │ 0.285062  │ 0.627526 │ 0.865243  │ 0.810667  │
## │ 9   │ 0.71528    │ 0.59901  │ 0.373738  │ 0.181532 │ 0.981097  │ 0.840872  │
## │ 10  │ 0.172221   │ 0.214106 │ 0.773122  │ 0.745432 │ 0.174569  │ 0.405642  │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Also, we can select a column by using its name as a symbol or using the “.” operator:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;## take the column x1 using &amp;quot;.&amp;quot; operator:
foo.x1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 100-element Array{Float64,1}:
##  0.28214992234732095  
##  0.457433387013769    
##  0.7622760096436174   
##  0.1770849027679091   
##  0.17886641307538254  
##  0.0033819547622031543
##  0.030609062287156208 
##  0.5708131090665298   
##  0.7152800256200742   
##  0.1722209038867224   
##  ⋮                    
##  0.06866484109670234  
##  0.8420471953808448   
##  0.9853718808939396   
##  0.4265395276232895   
##  0.8893025369476153   
##  0.05413910561339663  
##  0.1501427153699717   
##  0.4887911280810542   
##  0.5777351349130835&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;## Take the column using &amp;quot;x1&amp;quot; as a symbol:
foo[:x1]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 100-element Array{Float64,1}:
##  0.28214992234732095  
##  0.457433387013769    
##  0.7622760096436174   
##  0.1770849027679091   
##  0.17886641307538254  
##  0.0033819547622031543
##  0.030609062287156208 
##  0.5708131090665298   
##  0.7152800256200742   
##  0.1722209038867224   
##  ⋮                    
##  0.06866484109670234  
##  0.8420471953808448   
##  0.9853718808939396   
##  0.4265395276232895   
##  0.8893025369476153   
##  0.05413910561339663  
##  0.1501427153699717   
##  0.4887911280810542   
##  0.5777351349130835&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that the return will be an Array. To select one or more column and return
them as a DataFrame type, we use the double brackets syntax:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;using DataFramesMeta
## take column x1 as DataFrame
@linq foo[[:x1]] |&amp;gt; first(5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 5×1 DataFrame
## │ Row │ x1       │
## │     │ Float64  │
## ├─────┼──────────┤
## │ 1   │ 0.28215  │
## │ 2   │ 0.457433 │
## │ 3   │ 0.762276 │
## │ 4   │ 0.177085 │
## │ 5   │ 0.178866 │&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;## Take column x1 an x2:
@linq foo[[:x1, :x2]] |&amp;gt; first(5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 5×2 DataFrame
## │ Row │ x1       │ x2       │
## │     │ Float64  │ Float64  │
## ├─────┼──────────┼──────────┤
## │ 1   │ 0.28215  │ 0.953277 │
## │ 2   │ 0.457433 │ 0.357775 │
## │ 3   │ 0.762276 │ 0.573336 │
## │ 4   │ 0.177085 │ 0.895052 │
## │ 5   │ 0.178866 │ 0.43665  │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are some new things here. The &lt;code&gt;first()&lt;/code&gt; function aims to just show the first
lines of our dataset. Similarly, &lt;code&gt;last()&lt;/code&gt; performs the same, but showing us the last
lines. Also, you may have noticed the use of the &lt;strong&gt;“|&amp;gt;”&lt;/strong&gt; operator. This is the
&lt;strong&gt;pipe&lt;/strong&gt; symbol in Julia. If you are familiar with &lt;strong&gt;R&lt;/strong&gt; programming language, it
works similarly to the &lt;strong&gt;“%&amp;gt;%”&lt;/strong&gt; operator from &lt;em&gt;magrittr&lt;/em&gt; package, but with some
limitations. For example, we can not pipe to a specific argument in a
subsequent function, so that’s why the use of &lt;strong&gt;&lt;span class=&#34;citation&#34;&gt;@linq&lt;/span&gt;&lt;/strong&gt; from &lt;strong&gt;DataFramesMeta&lt;/strong&gt;
package. For now just take these commands for granted. In another post I will show
how to use the functionalities of the metaprogramming tools for &lt;strong&gt;DataFrames&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Another trivial task we can perform with column is to add or alter columns in a
DataFrame. For example, let’s create a new column which will be a sequence between
1 and until 100 by 0.5:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;## To create a sequence, use the function range():
foo[:new_column] = range(1, step = 0.5, length = nrow(foo));
foo[:, :new_column]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 100-element Array{Float64,1}:
##   1.0
##   1.5
##   2.0
##   2.5
##   3.0
##   3.5
##   4.0
##   4.5
##   5.0
##   5.5
##   ⋮  
##  46.5
##  47.0
##  47.5
##  48.0
##  48.5
##  49.0
##  49.5
##  50.0
##  50.5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can also add column using the &lt;code&gt;insertcols!()&lt;/code&gt; function. The syntax allow us to
specify in which position we want to add the column in the DataFrame:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;## syntax: insert!(dataset, position, column_name =&amp;gt; array)
insertcols!(foo, 2, :new_colum2 =&amp;gt; range(1, step = 0.5, length = nrow(foo)));
first(foo, 3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3×12 DataFrame. Omitted printing of 6 columns
## │ Row │ x1       │ new_colum2 │ x2       │ x3        │ x4       │ x5       │
## │     │ Float64  │ Float64    │ Float64  │ Float64   │ Float64  │ Float64  │
## ├─────┼──────────┼────────────┼──────────┼───────────┼──────────┼──────────┤
## │ 1   │ 0.28215  │ 1.0        │ 0.953277 │ 0.0345734 │ 0.380847 │ 0.831492 │
## │ 2   │ 0.457433 │ 1.5        │ 0.357775 │ 0.45568   │ 0.374921 │ 0.57703  │
## │ 3   │ 0.762276 │ 2.0        │ 0.573336 │ 0.0349542 │ 0.658953 │ 0.4545   │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note the use of the &lt;strong&gt;“!”&lt;/strong&gt; in &lt;code&gt;insertcols!()&lt;/code&gt; function. This means that the function
is altering the object in memory rather than in a “virtual copy” that later needs
to be assigned to a new variable. This is a behavior that can be used in other function
as well.&lt;/p&gt;
&lt;p&gt;Ok… But what if you want to do the opposite? that is, to remove a column?
Well… it is just as easy as to add it. Just use the &lt;code&gt;deletecols!()&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;deletecols!(foo, [:new_column, :new_colum2])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 100×10 DataFrame. Omitted printing of 4 columns
## │ Row │ x1         │ x2       │ x3        │ x4       │ x5        │ x6        │
## │     │ Float64    │ Float64  │ Float64   │ Float64  │ Float64   │ Float64   │
## ├─────┼────────────┼──────────┼───────────┼──────────┼───────────┼───────────┤
## │ 1   │ 0.28215    │ 0.953277 │ 0.0345734 │ 0.380847 │ 0.831492  │ 0.788669  │
## │ 2   │ 0.457433   │ 0.357775 │ 0.45568   │ 0.374921 │ 0.57703   │ 0.0701288 │
## │ 3   │ 0.762276   │ 0.573336 │ 0.0349542 │ 0.658953 │ 0.4545    │ 0.919184  │
## │ 4   │ 0.177085   │ 0.895052 │ 0.714325  │ 0.43383  │ 0.839534  │ 0.509621  │
## │ 5   │ 0.178866   │ 0.43665  │ 0.516935  │ 0.45325  │ 0.43443   │ 0.807217  │
## │ 6   │ 0.00338195 │ 0.516974 │ 0.287649  │ 0.569926 │ 0.463839  │ 0.626427  │
## │ 7   │ 0.0306091  │ 0.171283 │ 0.676435  │ 0.651781 │ 0.0673628 │ 0.759895  │
## ⋮
## │ 93  │ 0.842047   │ 0.156874 │ 0.972108  │ 0.121516 │ 0.824025  │ 0.319138  │
## │ 94  │ 0.985372   │ 0.482079 │ 0.0765152 │ 0.818235 │ 0.546266  │ 0.561243  │
## │ 95  │ 0.42654    │ 0.17668  │ 0.835386  │ 0.065945 │ 0.309747  │ 0.0293535 │
## │ 96  │ 0.889303   │ 0.66188  │ 0.971318  │ 0.547523 │ 0.170187  │ 0.987903  │
## │ 97  │ 0.0541391  │ 0.436057 │ 0.434473  │ 0.978984 │ 0.394627  │ 0.395319  │
## │ 98  │ 0.150143   │ 0.748007 │ 0.984081  │ 0.850741 │ 0.310097  │ 0.090252  │
## │ 99  │ 0.488791   │ 0.290897 │ 0.412977  │ 0.586124 │ 0.0231072 │ 0.597277  │
## │ 100 │ 0.577735   │ 0.969342 │ 0.525567  │ 0.19326  │ 0.491485  │ 0.622967  │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now suppose that you do not want to delete a colum, but just change its name.
For this task, I am afraid there is a very difficult function to remember
the name: &lt;code&gt;rename()&lt;/code&gt;. The syntax is as follows:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;## rename(dataFrame, :old_name =&amp;gt; :new_name)
rename(foo, :x1 =&amp;gt; :A1, :x2 =&amp;gt; :A2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 100×10 DataFrame. Omitted printing of 4 columns
## │ Row │ A1         │ A2       │ x3        │ x4       │ x5        │ x6        │
## │     │ Float64    │ Float64  │ Float64   │ Float64  │ Float64   │ Float64   │
## ├─────┼────────────┼──────────┼───────────┼──────────┼───────────┼───────────┤
## │ 1   │ 0.28215    │ 0.953277 │ 0.0345734 │ 0.380847 │ 0.831492  │ 0.788669  │
## │ 2   │ 0.457433   │ 0.357775 │ 0.45568   │ 0.374921 │ 0.57703   │ 0.0701288 │
## │ 3   │ 0.762276   │ 0.573336 │ 0.0349542 │ 0.658953 │ 0.4545    │ 0.919184  │
## │ 4   │ 0.177085   │ 0.895052 │ 0.714325  │ 0.43383  │ 0.839534  │ 0.509621  │
## │ 5   │ 0.178866   │ 0.43665  │ 0.516935  │ 0.45325  │ 0.43443   │ 0.807217  │
## │ 6   │ 0.00338195 │ 0.516974 │ 0.287649  │ 0.569926 │ 0.463839  │ 0.626427  │
## │ 7   │ 0.0306091  │ 0.171283 │ 0.676435  │ 0.651781 │ 0.0673628 │ 0.759895  │
## ⋮
## │ 93  │ 0.842047   │ 0.156874 │ 0.972108  │ 0.121516 │ 0.824025  │ 0.319138  │
## │ 94  │ 0.985372   │ 0.482079 │ 0.0765152 │ 0.818235 │ 0.546266  │ 0.561243  │
## │ 95  │ 0.42654    │ 0.17668  │ 0.835386  │ 0.065945 │ 0.309747  │ 0.0293535 │
## │ 96  │ 0.889303   │ 0.66188  │ 0.971318  │ 0.547523 │ 0.170187  │ 0.987903  │
## │ 97  │ 0.0541391  │ 0.436057 │ 0.434473  │ 0.978984 │ 0.394627  │ 0.395319  │
## │ 98  │ 0.150143   │ 0.748007 │ 0.984081  │ 0.850741 │ 0.310097  │ 0.090252  │
## │ 99  │ 0.488791   │ 0.290897 │ 0.412977  │ 0.586124 │ 0.0231072 │ 0.597277  │
## │ 100 │ 0.577735   │ 0.969342 │ 0.525567  │ 0.19326  │ 0.491485  │ 0.622967  │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We could also add the &lt;strong&gt;“!”&lt;/strong&gt; to the &lt;code&gt;rename()&lt;/code&gt; function to alter the DataFrame
in memory.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;lets-talk-about-missing-values&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Let’s talk about missing values:&lt;/h2&gt;
&lt;p&gt;Missing values are represented in Julia with &lt;strong&gt;missing&lt;/strong&gt; value. When an array
contains missing values, it automatically creates an appropriate union type:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;x = [1.0, 2.0, missing]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3-element Array{Union{Missing, Float64},1}:
##  1.0     
##  2.0     
##   missing&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;typeof(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Array{Union{Missing, Float64},1}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;typeof.(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3-element Array{DataType,1}:
##  Float64
##  Float64
##  Missing&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To check if a particular element in an array is missing, we use the &lt;code&gt;ismissing()&lt;/code&gt;
function:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;ismissing.([1.0, 2.0, missing])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3-element BitArray{1}:
##  false
##  false
##   true&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is important to notice that &lt;em&gt;missing&lt;/em&gt; comparison produces &lt;em&gt;missing&lt;/em&gt; as a result:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;missing == missing&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;isequal&lt;/strong&gt; and &lt;strong&gt;===&lt;/strong&gt; can be used to produce the results of type &lt;em&gt;Bool&lt;/em&gt;:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;isequal(missing, missing)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## true&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;missing === missing&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## true&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Other functions are available to work with missing values. For instance, suppose
we want an array with only non-missing values, we use the &lt;code&gt;skipmissing()&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;x |&amp;gt; skipmissing |&amp;gt; collect&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 2-element Array{Float64,1}:
##  1.0
##  2.0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, we use the &lt;code&gt;collect()&lt;/code&gt; function as the &lt;code&gt;skipmissing()&lt;/code&gt; returns an iterator.&lt;/p&gt;
&lt;p&gt;To replace the missing values with some other value we can use the
&lt;code&gt;Missings.replace()&lt;/code&gt; function. For example, suppose we want to change the missing
values by &lt;em&gt;NaN&lt;/em&gt;:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;Missings.replace(x, NaN) |&amp;gt; collect&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3-element Array{Float64,1}:
##    1.0
##    2.0
##  NaN&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We also can use use other ways to perform the same operation:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;## Using coalesce() function:
coalesce.(x, NaN)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3-element Array{Float64,1}:
##    1.0
##    2.0
##  NaN&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;## Using recode() function:
recode(x, missing =&amp;gt; NaN)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3-element Array{Float64,1}:
##    1.0
##    2.0
##  NaN&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Until now, we have only talked about missing values in arrays. But what about missing
values in DataFrames? To start, let’s create a DataFrame with some missing values:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;x = DataFrame(A = [1, missing, 3, 4], B = [&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, missing, &amp;quot;C&amp;quot;])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 4×2 DataFrame
## │ Row │ A       │ B       │
## │     │ Int64⍰  │ String⍰ │
## ├─────┼─────────┼─────────┤
## │ 1   │ 1       │ A       │
## │ 2   │ missing │ B       │
## │ 3   │ 3       │ missing │
## │ 4   │ 4       │ C       │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For some analysis, we would want only the rows with non-missing values. One way
to achieve this is making use of the &lt;code&gt;completecases()&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;x[completecases(x), :]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 2×2 DataFrame
## │ Row │ A      │ B       │
## │     │ Int64⍰ │ String⍰ │
## ├─────┼────────┼─────────┤
## │ 1   │ 1      │ A       │
## │ 2   │ 4      │ C       │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;completecases()&lt;/code&gt; function returns an boolean array with value &lt;em&gt;true&lt;/em&gt; for
rows that have non-missing values and &lt;em&gt;false&lt;/em&gt; otherwise. For those who are familiar
with &lt;strong&gt;R&lt;/strong&gt;, this is the same behavior as the &lt;em&gt;complete.cases()&lt;/em&gt; function from &lt;em&gt;stats&lt;/em&gt; package.&lt;/p&gt;
&lt;p&gt;Another option to return the rows with non-missing values of a DataFrame in Julia
is to use the &lt;code&gt;dropmissing()&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;dropmissing(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 2×2 DataFrame
## │ Row │ A      │ B       │
## │     │ Int64⍰ │ String⍰ │
## ├─────┼────────┼─────────┤
## │ 1   │ 1      │ A       │
## │ 2   │ 4      │ C       │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and again, for &lt;strong&gt;R&lt;/strong&gt; users is the same behavior as &lt;em&gt;na.omit()&lt;/em&gt; function.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;merging-dataframes&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Merging DataFrames:&lt;/h2&gt;
&lt;p&gt;Often, we need to combine two or more DataFrames together based on some common
column(s) among them. For example, suppose we have two DataFrames:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;df1 = DataFrame(x = 1:3, y = 4:6)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3×2 DataFrame
## │ Row │ x     │ y     │
## │     │ Int64 │ Int64 │
## ├─────┼───────┼───────┤
## │ 1   │ 1     │ 4     │
## │ 2   │ 2     │ 5     │
## │ 3   │ 3     │ 6     │&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;df2 = DataFrame(x = 1:3, z = &amp;#39;d&amp;#39;:&amp;#39;f&amp;#39;, new = 11:13)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3×3 DataFrame
## │ Row │ x     │ z    │ new   │
## │     │ Int64 │ Char │ Int64 │
## ├─────┼───────┼──────┼───────┤
## │ 1   │ 1     │ &amp;#39;d&amp;#39;  │ 11    │
## │ 2   │ 2     │ &amp;#39;e&amp;#39;  │ 12    │
## │ 3   │ 3     │ &amp;#39;f&amp;#39;  │ 13    │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which have the column &lt;em&gt;x&lt;/em&gt; in common. To merge these two tables, we use the
&lt;code&gt;join()&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;join(df1, df2, on = :x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3×4 DataFrame
## │ Row │ x     │ y     │ z    │ new   │
## │     │ Int64 │ Int64 │ Char │ Int64 │
## ├─────┼───────┼───────┼──────┼───────┤
## │ 1   │ 1     │ 4     │ &amp;#39;d&amp;#39;  │ 11    │
## │ 2   │ 2     │ 5     │ &amp;#39;e&amp;#39;  │ 12    │
## │ 3   │ 3     │ 6     │ &amp;#39;f&amp;#39;  │ 13    │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That’s it!! We merge our DataFrames altogether. But that’s the default behavior of
the function. There is more to explore. Essentially, &lt;code&gt;join()&lt;/code&gt; takes 4 arguments:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DataFrame 1&lt;/li&gt;
&lt;li&gt;DataFrame 2&lt;/li&gt;
&lt;li&gt;on = the column(s) to be the key in merging;&lt;/li&gt;
&lt;li&gt;kind = type of the merge (left, right, inner, outer, …)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The &lt;em&gt;kind&lt;/em&gt; argument specifies the type of join we are interested in performing.
The definition of each one is as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Inner&lt;/em&gt;: The output contains rows for values of the key that exist
in &lt;strong&gt;BOTH&lt;/strong&gt; the first (left) and second (right) arguments to
join;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Left&lt;/em&gt;: The output contains rows for values of the key that exist in
the first (left) argument to join, whether or not that value
exists in the second (right) argument;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Right&lt;/em&gt;: The output contains rows for values of the key that exist in
the second (right) argument to join, whether or not that
value exists in the first (left) argument;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Outer&lt;/em&gt;: The output contains rows for values of the key that exist in
the first (left) &lt;strong&gt;OR&lt;/strong&gt; second (right) argument to join;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;and here are the “&lt;em&gt;strange&lt;/em&gt;” ones:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Semi&lt;/em&gt;: Like an inner join, but output is restricted to columns from
the first (left) argument to join;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Anti&lt;/em&gt;: The output contains rows for values of the key that exist in
the first (left) but &lt;strong&gt;NOT&lt;/strong&gt; in the second (right) argument to
join. As with semi joins, output is restricted to columns
from the first (left) argument.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you are familiar with &lt;em&gt;SQL&lt;/em&gt; or with the join functions from &lt;em&gt;dplyr&lt;/em&gt; package in &lt;strong&gt;R&lt;/strong&gt;,
it is the same concept.&lt;/p&gt;
&lt;p&gt;To illustrate how the different kind of joins work, let’s create more DataFrames
to demonstrate each type of join:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;Names = DataFrame(ID = [20, 40], Name = [&amp;quot;John Doe&amp;quot;, &amp;quot;Jane Doe&amp;quot;])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 2×2 DataFrame
## │ Row │ ID    │ Name     │
## │     │ Int64 │ String   │
## ├─────┼───────┼──────────┤
## │ 1   │ 20    │ John Doe │
## │ 2   │ 40    │ Jane Doe │&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;jobs = DataFrame(ID = [20, 60], Job = [&amp;quot;Lawyer&amp;quot;, &amp;quot;Astronaut&amp;quot;])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 2×2 DataFrame
## │ Row │ ID    │ Job       │
## │     │ Int64 │ String    │
## ├─────┼───────┼───────────┤
## │ 1   │ 20    │ Lawyer    │
## │ 2   │ 60    │ Astronaut │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the Names and jobs DataFrame, we have the ID column as the key to perform the
join. But notice that the ID values are not equal between the DataFrames. Now
let’s perform the joins:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;join(Names, jobs, on = :ID, kind = :inner)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 1×3 DataFrame
## │ Row │ ID    │ Name     │ Job    │
## │     │ Int64 │ String   │ String │
## ├─────┼───────┼──────────┼────────┤
## │ 1   │ 20    │ John Doe │ Lawyer │&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;join(Names, jobs, on = :ID, kind = :left)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 2×3 DataFrame
## │ Row │ ID    │ Name     │ Job     │
## │     │ Int64 │ String   │ String⍰ │
## ├─────┼───────┼──────────┼─────────┤
## │ 1   │ 20    │ John Doe │ Lawyer  │
## │ 2   │ 40    │ Jane Doe │ missing │&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;join(Names, jobs, on = :ID, kind = :right)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 2×3 DataFrame
## │ Row │ ID    │ Name     │ Job       │
## │     │ Int64 │ String⍰  │ String    │
## ├─────┼───────┼──────────┼───────────┤
## │ 1   │ 20    │ John Doe │ Lawyer    │
## │ 2   │ 60    │ missing  │ Astronaut │&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;join(Names, jobs, on = :ID, kind = :outer)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3×3 DataFrame
## │ Row │ ID    │ Name     │ Job       │
## │     │ Int64 │ String⍰  │ String⍰   │
## ├─────┼───────┼──────────┼───────────┤
## │ 1   │ 20    │ John Doe │ Lawyer    │
## │ 2   │ 40    │ Jane Doe │ missing   │
## │ 3   │ 60    │ missing  │ Astronaut │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Semi&lt;/em&gt; and &lt;em&gt;anti&lt;/em&gt; join have a more uncommon behavior. Semi join returns the rows
from the left which &lt;strong&gt;DO MATCH&lt;/strong&gt; with the ID from the right:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;join(Names, jobs, on = :ID, kind = :semi)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 1×2 DataFrame
## │ Row │ ID    │ Name     │
## │     │ Int64 │ String   │
## ├─────┼───────┼──────────┤
## │ 1   │ 20    │ John Doe │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Anti join returns the rows from the left which &lt;strong&gt;DO NOT MATCH&lt;/strong&gt; with
the ID from the right&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;join(Names, jobs, on = :ID, kind = :anti)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 1×2 DataFrame
## │ Row │ ID    │ Name     │
## │     │ Int64 │ String   │
## ├─────┼───────┼──────────┤
## │ 1   │ 40    │ Jane Doe │&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;split-apply-combine&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Split-Apply-Combine:&lt;/h2&gt;
&lt;p&gt;Some common tasks involve splitting the data into groups, applying some function
to each of these groups and gathering the results to analyze later on. This is the
split-apply-combine strategy described in the paper “&lt;a href=&#34;https://www.jstatsoft.org/article/view/v040i01&#34;&gt;The Split-Apply-Combine Strategy for Data analysis&lt;/a&gt;” written by Hadley Wickham, creator
of many &lt;strong&gt;R&lt;/strong&gt; packages, including &lt;em&gt;ggplot2&lt;/em&gt; and &lt;em&gt;dplyr&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The DataFrames package in Julia supports the &lt;strong&gt;Split-Apply-Combine&lt;/strong&gt; strategy
through the &lt;code&gt;by()&lt;/code&gt; function, which takes three arguments:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DataFrame;&lt;/li&gt;
&lt;li&gt;one or more column names to split on;&lt;/li&gt;
&lt;li&gt;a function or expression to apply to each subset;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To illustrate its usage, let’s make use of the &lt;em&gt;RDatasets&lt;/em&gt; package, which gives
access to some preloaded well known datasets from R packages.&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;using RDatasets
foo = dataset(&amp;quot;datasets&amp;quot;, &amp;quot;iris&amp;quot;);
first(foo, 5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 5×5 DataFrame
## │ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species      │
## │     │ Float64     │ Float64    │ Float64     │ Float64    │ Categorical… │
## ├─────┼─────────────┼────────────┼─────────────┼────────────┼──────────────┤
## │ 1   │ 5.1         │ 3.5        │ 1.4         │ 0.2        │ setosa       │
## │ 2   │ 4.9         │ 3.0        │ 1.4         │ 0.2        │ setosa       │
## │ 3   │ 4.7         │ 3.2        │ 1.3         │ 0.2        │ setosa       │
## │ 4   │ 4.6         │ 3.1        │ 1.5         │ 0.2        │ setosa       │
## │ 5   │ 5.0         │ 3.6        │ 1.4         │ 0.2        │ setosa       │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A trivial task is to find how many of each “Species” there are in the
dataset. One way to do this is to apply the &lt;strong&gt;Split-Apply-Combine&lt;/strong&gt; strategy: &lt;strong&gt;split&lt;/strong&gt;
the data into the &lt;em&gt;Species&lt;/em&gt; column, &lt;strong&gt;apply&lt;/strong&gt; the &lt;code&gt;nrow()&lt;/code&gt; function to this
splitted dataset, and &lt;strong&gt;combine&lt;/strong&gt; the results:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;## Syntax: by(dataset, :name_column_to_split, name_function)
by(foo, :Species, nrow)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3×2 DataFrame
## │ Row │ Species      │ x1    │
## │     │ Categorical… │ Int64 │
## ├─────┼──────────────┼───────┤
## │ 1   │ setosa       │ 50    │
## │ 2   │ versicolor   │ 50    │
## │ 3   │ virginica    │ 50    │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can also make use of &lt;strong&gt;anonymous&lt;/strong&gt; function:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;by(foo, :Species, x -&amp;gt; DataFrame(N = nrow(x)))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3×2 DataFrame
## │ Row │ Species      │ N     │
## │     │ Categorical… │ Int64 │
## ├─────┼──────────────┼───────┤
## │ 1   │ setosa       │ 50    │
## │ 2   │ versicolor   │ 50    │
## │ 3   │ virginica    │ 50    │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One of the advantages of using anonymous function inside the &lt;code&gt;by()&lt;/code&gt; function is
that we can format the resulted output and apply as many function as we want:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;## Applying the count, mean and standard deviation function:
by(foo, :Species, x -&amp;gt; DataFrame(N = nrow(x),
                                 avg_PetalLength = mean(x[:PetalLength]),
                                 std_PetalWidth = std(x[:PetalWidth])))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3×4 DataFrame
## │ Row │ Species      │ N     │ avg_PetalLength │ std_PetalWidth │
## │     │ Categorical… │ Int64 │ Float64         │ Float64        │
## ├─────┼──────────────┼───────┼─────────────────┼────────────────┤
## │ 1   │ setosa       │ 50    │ 1.462           │ 0.105386       │
## │ 2   │ versicolor   │ 50    │ 4.26            │ 0.197753       │
## │ 3   │ virginica    │ 50    │ 5.552           │ 0.27465        │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another way to use the &lt;strong&gt;Split-Apply-Combine&lt;/strong&gt; strategy is implementing the
&lt;code&gt;aggregate()&lt;/code&gt; function, which also takes three arguments:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DataFrame;&lt;/li&gt;
&lt;li&gt;one or more column names to split on;&lt;/li&gt;
&lt;li&gt;one or more function to be applied &lt;strong&gt;ON THE COLUMNS NOT USED TO SPLIT&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The difference between &lt;code&gt;by()&lt;/code&gt; and &lt;code&gt;aggregate()&lt;/code&gt; function is that in the
latter, the function(s) will be applied to each column not used in
the split part.&lt;/p&gt;
&lt;p&gt;For instance, let’s say you want the average of each colum for each &lt;em&gt;Species&lt;/em&gt;.
Instead of using &lt;code&gt;by()&lt;/code&gt; with an anonymous function and writing the name of all columns
we can do:&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;aggregate(foo, :Species, [mean])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3×5 DataFrame. Omitted printing of 1 columns
## │ Row │ Species      │ SepalLength_mean │ SepalWidth_mean │ PetalLength_mean │
## │     │ Categorical… │ Float64          │ Float64         │ Float64          │
## ├─────┼──────────────┼──────────────────┼─────────────────┼──────────────────┤
## │ 1   │ setosa       │ 5.006            │ 3.428           │ 1.462            │
## │ 2   │ versicolor   │ 5.936            │ 2.77            │ 4.26             │
## │ 3   │ virginica    │ 6.588            │ 2.974           │ 5.552            │&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that Julia only display output that fits the screen. Pay
attention to the message “&lt;em&gt;Omitted printing of 1 columns&lt;/em&gt;”. To
overcome this, use the &lt;code&gt;show()&lt;/code&gt; as advised before.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;reading-and-writting-csv-files&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Reading and Writting CSV files:&lt;/h1&gt;
&lt;p&gt;Last but not least, let’s see how to read and write CSV files into/from Julia.
Although this is not exactly handled by the &lt;em&gt;DataFrames&lt;/em&gt; package, the task of
reading/writing CSV files are so natural when working with DataFrame that I will
show you the basics.&lt;/p&gt;
&lt;p&gt;To read/write CSV files, we use the &lt;strong&gt;CSV&lt;/strong&gt; package. To demonstrate its usage,
let’s work with the iris dataset and write a CSV file to a local computer. Then,
we read it back.&lt;/p&gt;
&lt;p&gt;So, first we are going to write the &lt;em&gt;foo&lt;/em&gt; object (which contains the &lt;em&gt;iris&lt;/em&gt; dataset)
to a CSV file. To do this we will use the &lt;code&gt;CSV.write()&lt;/code&gt; function. Some useful
arguments in CSV.write are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;delim&lt;/em&gt; : the file’s delimeter. Default ‘,’;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;header&lt;/em&gt; : boolean whether to write the colnames from source;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;colnames&lt;/em&gt; : provide colnames to be written;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;append&lt;/em&gt; : bool to indicate if it to append data;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;missingstring&lt;/em&gt; : string that indicates how missing values will be represented.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;    using CSV
    CSV.write(&amp;quot;iris.csv&amp;quot;, foo, missingsstring = &amp;quot;NA&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To read a CSV file, we use the &lt;code&gt;CSV.read()&lt;/code&gt;. Some useful arguments are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;delim&lt;/em&gt; : a Char or String that indicates how columns are delimited in a file’s delimeter. Default ‘,’;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;decimal&lt;/em&gt; : a Char indicating how decimals are separated in
floats. Default ‘.’ ;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;limit&lt;/em&gt; : indicates the total number of rows to read;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;header&lt;/em&gt; : provide manually the names of the columns;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;types&lt;/em&gt; : a Vector or Dict of types to be used for column types.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;iris = CSV.read(&amp;quot;iris.csv&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is important to note that when loading in a DataFrame from a CSV, all columns
allow Missing by default.&lt;/p&gt;
&lt;p&gt;This is the basics of reading/writting CSV files in Julia. To get more details
refers to the &lt;a href=&#34;http://juliadata.github.io/CSV.jl/latest/#High-level-interface-1&#34;&gt;official documentation&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusion&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Conclusion:&lt;/h1&gt;
&lt;p&gt;This post was a very small introduction to the &lt;strong&gt;DataFrames&lt;/strong&gt; packages in Julia.
After reading this post you will be able to read CSV datasets and perform some
tasks with the data at hand.&lt;/p&gt;
&lt;p&gt;In the following posts, we will explore more advanced tricks to perform data
wrangling and exploratory data analysis. At each step we are going to build
knowledge to completely use Julia to perform data analysis for any problem that
you might face.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
