<!DOCTYPE html>
<html>

    <head>
        <title> Using Julia for Data Science  &middot; Cleyton Farias </title>

        <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.53" />


<script   src="https://code.jquery.com/jquery-3.1.1.min.js"   integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="   crossorigin="anonymous"></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">


<link rel="stylesheet" href="/css/nix.css">



<link rel="shortcut icon" href="/data.png">



<link href="https://fonts.googleapis.com/css?family=Inconsolata%7COpen+Sans%7CConcert+One" rel="stylesheet">




    </head>

    <body>
        <header>
<nav class="navbar navbar-default navbar-fixed-top navbar-inverse font-header">
	<div class="container-fluid">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse-1" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" id="green-terminal" href=/>cleyton@farias ~ $</a>
		</div>

		
		<div class="collapse navbar-collapse" id="navbar-collapse-1">
			<ul class="nav navbar-nav navbar-right">
				<li>
					<a href="/">/home/cleyton</a>
				</li>
				
				
				<li class="dropdown">
                    
            		<a href="/research/">~/research</a>
            		
        		</li>
        		
				
				<li class="dropdown">
                    
            		<a href="/talks/">~/talks</a>
            		
        		</li>
        		
				
				<li class="dropdown">
                    
            		<a href="/posts/">~/posts</a>
            		
        		</li>
        		
				
				<li class="dropdown">
                    
            		<a href="/vitae/">~/vitae</a>
            		
        		</li>
        		

			</ul>
		</div>
	</div>
</nav>
</header>

        <div class="container wrapper">
            <h1><a href="/posts/using-julia-for-data-science/">Using Julia for Data Science </a></h1>
            <span class="post-date">Feb 11, 2019 </span>
            <div class="post-content">
                


<p>This a quick introduction to the Julia programming language. The aim of this post
is to present to you how you can easily install and work rightaway with
datasets with Julia.</p>
<div id="why-julia" class="section level1">
<h1>Why Julia?</h1>
<p>Glad you asked! Julia is a high level programming language released in 2012 by a
team of MIT researchers. Since its beginning, the aim was to solve the so called
two-language programing problem: easy to use functionalities of interpretable languages
(Python, R, Matlab) vs high performance of compiled languages (C, C++, Fortran).
According to its creators:</p>
<blockquote>
<p>We want a language that’s open source, with a liberal license.
We want the speed of C with the dynamism of Ruby.
We want a language that’s homoiconic, with true macros like Lisp, but with obvious,
familiar mathematical notation like Matlab. We want something as usable for
general programming as Python, as easy for statistics as R, as natural for string
processing as Perl, as powerful for linear algebra as Matlab, as good at gluing
programs together as the shell.
Something that is dirt simple to learn, yet keeps the most serious hackers happy.
We want it interactive and we want it compiled. — <a href="https://julialang.org/" target="_blank">julialang.org</a></p>
</blockquote>
<p>Hence, Julia was born. Combining the JIT (Just In Time) compiler and
Julia’s multiple-dispatch system plus the fact that its codebase is written
entirely in native language, Julia gives birth to the popular phrase in the
community:</p>
<p><strong>“Walks like Python, runs like C.”</strong></p>
</div>
<div id="installing-julia" class="section level1">
<h1>Installing Julia</h1>
<p>To play around with Julia there are some options. One obvious way is to download
the official binaries from the <a href="https://julialang.org/downloads/">site</a> for your
specific plataform (Windows, macOS, Linux, etc). At the
time of this writting, the <strong>Current stable release</strong> is <strong>v1.1.0</strong> and the
<strong>Long-term support release</strong> is <strong>v1.0.3</strong>. Once you downloaded and execute
the binaries, you will see the following window:</p>
<center>
<img src="julia.png" width="500" />
</center>
<p><br/></p>
<p>Another options is to use Julia in the browser on <a href="https://juliabox.com/">JuliaBox.com</a>
with Jupyter notebooks. No installation is required – just point your browser
there, login and start play around.</p>
<div id="installing-packages" class="section level2">
<h2>Installing Packages</h2>
<p>All the package management in Julia is performed by the <strong>Pkg</strong> package. To
install a given package we use <code>Pkg.add("package_name")</code>. In this tutorial we
are going to use some packages that are not pre-installed with Julia. To install
them, do the following:</p>
<pre><code>using Pkg
Pkg.add(&quot;DataFrames&quot;)
Pkg.add(&quot;DataFramesMeta&quot;)
Pkg.add(&quot;CSV&quot;)</code></pre>
<p>We installed three packages: <strong>DataFrames</strong> (which is the subject of this post),
<strong>DataFramesMeta</strong> (we will use some of its functionalities) and <strong>CSV</strong> (to read
and write CSV files).</p>
<p>Of course there is more about package management in Julia than I just showed.
A great introduction is presented in this <a href="https://www.youtube.com/watch?v=76KL8aSz0Sg">video</a> by Jane
Harriman. For more advanced usage, please refer to the <a href="https://docs.julialang.org/en/v1/stdlib/Pkg/index.html">official documentation</a>.</p>
</div>
</div>
<div id="introduction-to-dataframes-in-julia" class="section level1">
<h1>Introduction to DataFrames in Julia</h1>
<p>In Julia, tablular data is handled using the <strong>DataFrames</strong> package. Other packages
are commonly used to read/write data into/from Julia such as <strong>CSV</strong>.</p>
<p>A data frame is created using the <code>DataFrame()</code> function:</p>
<pre class="julia"><code>using DataFrames 
foo = DataFrame();
foo </code></pre>
<pre><code>## 0×0 DataFrame</code></pre>
<p>To use the functionalities of the package, let’s create some random data. I will
use the <code>rand()</code> function to generate random numbers to create an array 100 x 10
and convert it to a data frame:</p>
<pre class="julia"><code>foo = DataFrame(rand(100, 10));
foo </code></pre>
<pre><code>## 100×10 DataFrame. Omitted printing of 5 columns
## │ Row │ x1         │ x2          │ x3        │ x4        │ x5        │
## │     │ Float64    │ Float64     │ Float64   │ Float64   │ Float64   │
## ├─────┼────────────┼─────────────┼───────────┼───────────┼───────────┤
## │ 1   │ 0.49708    │ 0.0760758   │ 0.902615  │ 0.266038  │ 0.0543373 │
## │ 2   │ 0.00185941 │ 0.227116    │ 0.328533  │ 0.123489  │ 0.0806307 │
## │ 3   │ 0.70847    │ 0.270637    │ 0.314016  │ 0.144984  │ 0.911408  │
## │ 4   │ 0.806661   │ 0.325429    │ 0.197887  │ 0.654135  │ 0.0131468 │
## │ 5   │ 0.561396   │ 0.987613    │ 0.0988301 │ 0.417581  │ 0.0499511 │
## │ 6   │ 0.303344   │ 0.000183882 │ 0.472595  │ 0.792644  │ 0.63012   │
## │ 7   │ 0.263182   │ 0.386939    │ 0.135905  │ 0.82161   │ 0.243965  │
## ⋮
## │ 93  │ 0.263713   │ 0.552308    │ 0.358334  │ 0.666055  │ 0.41237   │
## │ 94  │ 0.666416   │ 0.10521     │ 0.828499  │ 0.499015  │ 0.290909  │
## │ 95  │ 0.542917   │ 0.414531    │ 0.779626  │ 0.284235  │ 0.944611  │
## │ 96  │ 0.485839   │ 0.0650952   │ 0.514224  │ 0.0459998 │ 0.298542  │
## │ 97  │ 0.668851   │ 0.337354    │ 0.661354  │ 0.544525  │ 0.7073    │
## │ 98  │ 0.172888   │ 0.445677    │ 0.204508  │ 0.330751  │ 0.798409  │
## │ 99  │ 0.502288   │ 0.767121    │ 0.674367  │ 0.476936  │ 0.98405   │
## │ 100 │ 0.975344   │ 0.824484    │ 0.580215  │ 0.0512332 │ 0.0237256 │</code></pre>
<p>Maybe you have noticed the “;” at the end of a command. It turns out that in Julia,
contrary to many other languages, <strong>everything is an expression</strong>, so it will return
a result. Hence, to <em>turn off</em> this return, we must include the “;” at the end of
each command.</p>
<p>To get the dimension of a data frame, we can use the <code>size()</code> function. Also,
similarly to <strong>R</strong> programming language, <code>nrow()</code> and <code>ncol()</code> are available to
get the number of rows and columns, respectively:</p>
<pre class="julia"><code>size(foo)</code></pre>
<pre><code>## (100, 10)</code></pre>
<pre class="julia"><code>nrow(foo)</code></pre>
<pre><code>## 100</code></pre>
<pre class="julia"><code>ncol(foo)</code></pre>
<pre><code>## 10</code></pre>
<p>Another basic task when working with datasets is to to get the names of each
variable contained in the table. We use the <code>names()</code> function to get the column
names:</p>
<pre class="julia"><code>names(foo)</code></pre>
<pre><code>## 10-element Array{Symbol,1}:
##  :x1 
##  :x2 
##  :x3 
##  :x4 
##  :x5 
##  :x6 
##  :x7 
##  :x8 
##  :x9 
##  :x10</code></pre>
<p>To get a summary of the dataset in general, we can use the function <code>describe()</code>:</p>
<pre class="julia"><code>describe(foo)</code></pre>
<pre><code>## 10×8 DataFrame. Omitted printing of 2 columns
## │ Row │ variable │ mean     │ min         │ median   │ max      │ nunique │
## │     │ Symbol   │ Float64  │ Float64     │ Float64  │ Float64  │ Nothing │
## ├─────┼──────────┼──────────┼─────────────┼──────────┼──────────┼─────────┤
## │ 1   │ x1       │ 0.505238 │ 0.00185941  │ 0.506336 │ 0.991531 │         │
## │ 2   │ x2       │ 0.513939 │ 0.000183882 │ 0.545725 │ 0.99326  │         │
## │ 3   │ x3       │ 0.480448 │ 0.00190438  │ 0.456662 │ 0.984221 │         │
## │ 4   │ x4       │ 0.507836 │ 0.00394632  │ 0.491661 │ 0.980787 │         │
## │ 5   │ x5       │ 0.494978 │ 0.0131439   │ 0.488369 │ 0.998313 │         │
## │ 6   │ x6       │ 0.54253  │ 0.0178545   │ 0.514572 │ 0.995788 │         │
## │ 7   │ x7       │ 0.528658 │ 0.00115237  │ 0.560111 │ 0.985792 │         │
## │ 8   │ x8       │ 0.551639 │ 0.00160092  │ 0.614201 │ 0.996695 │         │
## │ 9   │ x9       │ 0.555426 │ 0.00869291  │ 0.585682 │ 0.9731   │         │
## │ 10  │ x10      │ 0.513803 │ 0.00866124  │ 0.545865 │ 0.972464 │         │</code></pre>
<p>Note that there is a message indicating the omission of some columns. This is the
default behavior of Julia. To avoid this feature, we use the <code>show()</code> function
as follows:</p>
<pre><code>show(describe(foo), allcols = true)</code></pre>
<div id="manipulating-rows" class="section level2">
<h2>Manipulating Rows:</h2>
<p>Subset rows in Julia can be a little odd in the beginning, but once you get used to, it becomes
more logical. For example, suppose we want the rows where <em>x1</em> is above its average.
We could this as follows:</p>
<pre class="julia"><code>## Loading the Statistics package:
using Statistics
## Creating the conditional:
cond01 = foo[:x1] .&gt;= mean(foo[:x1]);
## Subsetting the rows:
foo[cond01, :] </code></pre>
<pre><code>## 50×10 DataFrame. Omitted printing of 4 columns
## │ Row │ x1       │ x2       │ x3        │ x4        │ x5        │ x6        │
## │     │ Float64  │ Float64  │ Float64   │ Float64   │ Float64   │ Float64   │
## ├─────┼──────────┼──────────┼───────────┼───────────┼───────────┼───────────┤
## │ 1   │ 0.70847  │ 0.270637 │ 0.314016  │ 0.144984  │ 0.911408  │ 0.804496  │
## │ 2   │ 0.806661 │ 0.325429 │ 0.197887  │ 0.654135  │ 0.0131468 │ 0.190051  │
## │ 3   │ 0.561396 │ 0.987613 │ 0.0988301 │ 0.417581  │ 0.0499511 │ 0.110993  │
## │ 4   │ 0.727377 │ 0.484745 │ 0.0906409 │ 0.484308  │ 0.951481  │ 0.18051   │
## │ 5   │ 0.726177 │ 0.036618 │ 0.448904  │ 0.626108  │ 0.397872  │ 0.757334  │
## │ 6   │ 0.688277 │ 0.730836 │ 0.489801  │ 0.0767411 │ 0.872669  │ 0.0658277 │
## │ 7   │ 0.675093 │ 0.627643 │ 0.848091  │ 0.960559  │ 0.557038  │ 0.0178545 │
## ⋮
## │ 43  │ 0.753184 │ 0.710247 │ 0.807203  │ 0.26981   │ 0.629433  │ 0.296894  │
## │ 44  │ 0.805409 │ 0.936288 │ 0.911651  │ 0.778715  │ 0.982858  │ 0.0315362 │
## │ 45  │ 0.825171 │ 0.299462 │ 0.35922   │ 0.475824  │ 0.177654  │ 0.762498  │
## │ 46  │ 0.78344  │ 0.630807 │ 0.449768  │ 0.462135  │ 0.385504  │ 0.971074  │
## │ 47  │ 0.666416 │ 0.10521  │ 0.828499  │ 0.499015  │ 0.290909  │ 0.965548  │
## │ 48  │ 0.542917 │ 0.414531 │ 0.779626  │ 0.284235  │ 0.944611  │ 0.465421  │
## │ 49  │ 0.668851 │ 0.337354 │ 0.661354  │ 0.544525  │ 0.7073    │ 0.800017  │
## │ 50  │ 0.975344 │ 0.824484 │ 0.580215  │ 0.0512332 │ 0.0237256 │ 0.145888  │</code></pre>
<p>What if we want two conditionals? For example, we want the same condition as before
and/or the rows where <em>x2</em> is greater than or equal its average? Now things
become trickier. Let’s check how we could do this:</p>
<pre class="julia"><code>## Creating the second conditional:
cond02 = foo[:x2] .&gt;= mean(foo[:x2]);
## Subsetting cond01 AND cond02:
foo[.&amp;(cond01, cond02), :]</code></pre>
<pre><code>## 25×10 DataFrame. Omitted printing of 4 columns
## │ Row │ x1       │ x2       │ x3        │ x4        │ x5        │ x6        │
## │     │ Float64  │ Float64  │ Float64   │ Float64   │ Float64   │ Float64   │
## ├─────┼──────────┼──────────┼───────────┼───────────┼───────────┼───────────┤
## │ 1   │ 0.561396 │ 0.987613 │ 0.0988301 │ 0.417581  │ 0.0499511 │ 0.110993  │
## │ 2   │ 0.688277 │ 0.730836 │ 0.489801  │ 0.0767411 │ 0.872669  │ 0.0658277 │
## │ 3   │ 0.675093 │ 0.627643 │ 0.848091  │ 0.960559  │ 0.557038  │ 0.0178545 │
## │ 4   │ 0.886306 │ 0.643214 │ 0.77237   │ 0.227103  │ 0.998313  │ 0.640681  │
## │ 5   │ 0.611724 │ 0.579188 │ 0.756683  │ 0.474946  │ 0.963713  │ 0.579605  │
## │ 6   │ 0.915895 │ 0.539141 │ 0.714367  │ 0.803454  │ 0.213395  │ 0.154624  │
## │ 7   │ 0.991531 │ 0.742785 │ 0.882392  │ 0.318182  │ 0.430602  │ 0.258591  │
## ⋮
## │ 18  │ 0.727817 │ 0.714513 │ 0.913134  │ 0.382902  │ 0.420951  │ 0.795467  │
## │ 19  │ 0.961572 │ 0.832898 │ 0.268962  │ 0.940274  │ 0.792974  │ 0.650306  │
## │ 20  │ 0.874026 │ 0.639226 │ 0.141408  │ 0.339593  │ 0.517996  │ 0.429874  │
## │ 21  │ 0.896738 │ 0.945713 │ 0.0783348 │ 0.689466  │ 0.111313  │ 0.268415  │
## │ 22  │ 0.753184 │ 0.710247 │ 0.807203  │ 0.26981   │ 0.629433  │ 0.296894  │
## │ 23  │ 0.805409 │ 0.936288 │ 0.911651  │ 0.778715  │ 0.982858  │ 0.0315362 │
## │ 24  │ 0.78344  │ 0.630807 │ 0.449768  │ 0.462135  │ 0.385504  │ 0.971074  │
## │ 25  │ 0.975344 │ 0.824484 │ 0.580215  │ 0.0512332 │ 0.0237256 │ 0.145888  │</code></pre>
<pre class="julia"><code>## Subsetting cond01 OR cond02:
foo[.|(cond01, cond02), :]</code></pre>
<pre><code>## 76×10 DataFrame. Omitted printing of 4 columns
## │ Row │ x1        │ x2       │ x3        │ x4         │ x5        │ x6       │
## │     │ Float64   │ Float64  │ Float64   │ Float64    │ Float64   │ Float64  │
## ├─────┼───────────┼──────────┼───────────┼────────────┼───────────┼──────────┤
## │ 1   │ 0.70847   │ 0.270637 │ 0.314016  │ 0.144984   │ 0.911408  │ 0.804496 │
## │ 2   │ 0.806661  │ 0.325429 │ 0.197887  │ 0.654135   │ 0.0131468 │ 0.190051 │
## │ 3   │ 0.561396  │ 0.987613 │ 0.0988301 │ 0.417581   │ 0.0499511 │ 0.110993 │
## │ 4   │ 0.311384  │ 0.666642 │ 0.350968  │ 0.6136     │ 0.960408  │ 0.106166 │
## │ 5   │ 0.329222  │ 0.871645 │ 0.590738  │ 0.370515   │ 0.838287  │ 0.640776 │
## │ 6   │ 0.300975  │ 0.724835 │ 0.883635  │ 0.00394632 │ 0.390245  │ 0.696164 │
## │ 7   │ 0.727377  │ 0.484745 │ 0.0906409 │ 0.484308   │ 0.951481  │ 0.18051  │
## ⋮
## │ 69  │ 0.78344   │ 0.630807 │ 0.449768  │ 0.462135   │ 0.385504  │ 0.971074 │
## │ 70  │ 0.0171508 │ 0.851893 │ 0.0686198 │ 0.232086   │ 0.519528  │ 0.914907 │
## │ 71  │ 0.263713  │ 0.552308 │ 0.358334  │ 0.666055   │ 0.41237   │ 0.787299 │
## │ 72  │ 0.666416  │ 0.10521  │ 0.828499  │ 0.499015   │ 0.290909  │ 0.965548 │
## │ 73  │ 0.542917  │ 0.414531 │ 0.779626  │ 0.284235   │ 0.944611  │ 0.465421 │
## │ 74  │ 0.668851  │ 0.337354 │ 0.661354  │ 0.544525   │ 0.7073    │ 0.800017 │
## │ 75  │ 0.502288  │ 0.767121 │ 0.674367  │ 0.476936   │ 0.98405   │ 0.388985 │
## │ 76  │ 0.975344  │ 0.824484 │ 0.580215  │ 0.0512332  │ 0.0237256 │ 0.145888 │</code></pre>
<p>In Julia, instead of the syntax <em>condition1 &amp; condition2</em>, which is more common in
other programming languages, we use <code>&amp;(condition1, condition2)</code> or
<code>|(condition1, condition2)</code> operators to perform multiple conditional
filtering.</p>
<p>Now, let’s say you have a DataFrame and you want to <strong>append</strong> rows to it.
There are a couple of ways of doing data. The first one is to use the <code>[data1; data2]</code>
syntax:</p>
<pre class="julia"><code>## Creating a DataFrame with 3 rows and 5 columns:
x = DataFrame(rand(3, 5));
## Let&#39;s add another line using [dataset1; dataset2] syntax:
[ x ; DataFrame(rand(1, 5)) ]</code></pre>
<pre><code>## 4×5 DataFrame
## │ Row │ x1         │ x2         │ x3       │ x4       │ x5       │
## │     │ Float64    │ Float64    │ Float64  │ Float64  │ Float64  │
## ├─────┼────────────┼────────────┼──────────┼──────────┼──────────┤
## │ 1   │ 0.194522   │ 0.277381   │ 0.963881 │ 0.487374 │ 0.143214 │
## │ 2   │ 0.394044   │ 0.136482   │ 0.134148 │ 0.179244 │ 0.145656 │
## │ 3   │ 0.00113255 │ 0.00667982 │ 0.381202 │ 0.562604 │ 0.982368 │
## │ 4   │ 0.312894   │ 0.776189   │ 0.951795 │ 0.270776 │ 0.148956 │</code></pre>
<p>We could get the same result using the <code>vcat()</code> function. According to the
documentation, <code>vcat()</code> performs <em>concatenation along dimension 1</em>, which means
it will concatenate rows. The syntax would be:</p>
<pre><code>## taking the first 2 lines and append with the third one:
vcat(x[1:2, :] , x[3, :])</code></pre>
<p>Another way to do that is using the function <code>append!()</code>. This function will append
a new row to the last row in a given DataFrame. Note that the column names <strong>must</strong>
match exactly.</p>
<pre class="julia"><code>## Column names matches
append!(x, DataFrame(rand(1, 5)))</code></pre>
<pre><code>## 4×5 DataFrame
## │ Row │ x1         │ x2         │ x3       │ x4       │ x5       │
## │     │ Float64    │ Float64    │ Float64  │ Float64  │ Float64  │
## ├─────┼────────────┼────────────┼──────────┼──────────┼──────────┤
## │ 1   │ 0.194522   │ 0.277381   │ 0.963881 │ 0.487374 │ 0.143214 │
## │ 2   │ 0.394044   │ 0.136482   │ 0.134148 │ 0.179244 │ 0.145656 │
## │ 3   │ 0.00113255 │ 0.00667982 │ 0.381202 │ 0.562604 │ 0.982368 │
## │ 4   │ 0.67002    │ 0.185472   │ 0.889916 │ 0.108378 │ 0.822146 │</code></pre>
<p>Note that if the column names between two DataFrames do not match , the <code>append!()</code>
function is going to throw an error. Although this kind of behavior is important
when we want to control for possible side effects, we might also prefer to not worry about
this and “<em>force</em>” the append procedure. In order to do this we can make use of
the <code>push!()</code> function.</p>
<pre class="julia"><code>## providing an Array:
push!(x, rand(ncol(x)))</code></pre>
<pre><code>## 5×5 DataFrame
## │ Row │ x1         │ x2         │ x3       │ x4       │ x5          │
## │     │ Float64    │ Float64    │ Float64  │ Float64  │ Float64     │
## ├─────┼────────────┼────────────┼──────────┼──────────┼─────────────┤
## │ 1   │ 0.194522   │ 0.277381   │ 0.963881 │ 0.487374 │ 0.143214    │
## │ 2   │ 0.394044   │ 0.136482   │ 0.134148 │ 0.179244 │ 0.145656    │
## │ 3   │ 0.00113255 │ 0.00667982 │ 0.381202 │ 0.562604 │ 0.982368    │
## │ 4   │ 0.67002    │ 0.185472   │ 0.889916 │ 0.108378 │ 0.822146    │
## │ 5   │ 0.504304   │ 0.878508   │ 0.61942  │ 0.175183 │ 0.000105632 │</code></pre>
<pre class="julia"><code>## providing an dictionary:
push!(x, Dict(:x1 =&gt; rand(),
              :x2 =&gt; rand(),
              :x3 =&gt; rand(),
              :x4 =&gt; rand(),
              :x5 =&gt; rand()))</code></pre>
<pre><code>## 6×5 DataFrame
## │ Row │ x1         │ x2         │ x3       │ x4       │ x5          │
## │     │ Float64    │ Float64    │ Float64  │ Float64  │ Float64     │
## ├─────┼────────────┼────────────┼──────────┼──────────┼─────────────┤
## │ 1   │ 0.194522   │ 0.277381   │ 0.963881 │ 0.487374 │ 0.143214    │
## │ 2   │ 0.394044   │ 0.136482   │ 0.134148 │ 0.179244 │ 0.145656    │
## │ 3   │ 0.00113255 │ 0.00667982 │ 0.381202 │ 0.562604 │ 0.982368    │
## │ 4   │ 0.67002    │ 0.185472   │ 0.889916 │ 0.108378 │ 0.822146    │
## │ 5   │ 0.504304   │ 0.878508   │ 0.61942  │ 0.175183 │ 0.000105632 │
## │ 6   │ 0.737065   │ 0.0172064  │ 0.366979 │ 0.427037 │ 0.30189     │</code></pre>
<p>As we can see, this function also accepts that we give a dictionary or an array
to append to a DataFrame.</p>
<p>So, there are at least 4 methods to add rows to the a DataFrame. Which one to use?
Let’s see how fast it is each function:</p>
<pre class="julia"><code>using BenchmarkTools
@btime [x ; DataFrame(rand(1, 5))];
@btime vcat(x, DataFrame(rand(1, 5)));
@btime append!(x, DataFrame(rand(1, 5)));
@btime push!(x, rand(1, 5));</code></pre>
</div>
<div id="manipulating-columns" class="section level2">
<h2>Manipulating Columns:</h2>
<p>One of the first things we would want to do when working with a dataset is selecting
some columns. In Julia, the syntax of selecting columns in DataFrames is similar to the one
used in <em>Matlab/Octave</em>. For instance, we can make use of the <strong>“:”</strong> symbol to represent
that we want all columns (or all rows) and/or a sequence of them:</p>
<pre class="julia"><code>## Taking all rows of the first 2 columns:
foo[:, 1:2]</code></pre>
<pre><code>## 100×2 DataFrame
## │ Row │ x1         │ x2          │
## │     │ Float64    │ Float64     │
## ├─────┼────────────┼─────────────┤
## │ 1   │ 0.49708    │ 0.0760758   │
## │ 2   │ 0.00185941 │ 0.227116    │
## │ 3   │ 0.70847    │ 0.270637    │
## │ 4   │ 0.806661   │ 0.325429    │
## │ 5   │ 0.561396   │ 0.987613    │
## │ 6   │ 0.303344   │ 0.000183882 │
## │ 7   │ 0.263182   │ 0.386939    │
## ⋮
## │ 93  │ 0.263713   │ 0.552308    │
## │ 94  │ 0.666416   │ 0.10521     │
## │ 95  │ 0.542917   │ 0.414531    │
## │ 96  │ 0.485839   │ 0.0650952   │
## │ 97  │ 0.668851   │ 0.337354    │
## │ 98  │ 0.172888   │ 0.445677    │
## │ 99  │ 0.502288   │ 0.767121    │
## │ 100 │ 0.975344   │ 0.824484    │</code></pre>
<pre class="julia"><code>## Taking the first 10 rows of all columns:
foo[1:10, :]</code></pre>
<pre><code>## 10×10 DataFrame. Omitted printing of 5 columns
## │ Row │ x1         │ x2          │ x3        │ x4       │ x5        │
## │     │ Float64    │ Float64     │ Float64   │ Float64  │ Float64   │
## ├─────┼────────────┼─────────────┼───────────┼──────────┼───────────┤
## │ 1   │ 0.49708    │ 0.0760758   │ 0.902615  │ 0.266038 │ 0.0543373 │
## │ 2   │ 0.00185941 │ 0.227116    │ 0.328533  │ 0.123489 │ 0.0806307 │
## │ 3   │ 0.70847    │ 0.270637    │ 0.314016  │ 0.144984 │ 0.911408  │
## │ 4   │ 0.806661   │ 0.325429    │ 0.197887  │ 0.654135 │ 0.0131468 │
## │ 5   │ 0.561396   │ 0.987613    │ 0.0988301 │ 0.417581 │ 0.0499511 │
## │ 6   │ 0.303344   │ 0.000183882 │ 0.472595  │ 0.792644 │ 0.63012   │
## │ 7   │ 0.263182   │ 0.386939    │ 0.135905  │ 0.82161  │ 0.243965  │
## │ 8   │ 0.311384   │ 0.666642    │ 0.350968  │ 0.6136   │ 0.960408  │
## │ 9   │ 0.147863   │ 0.108923    │ 0.888634  │ 0.75865  │ 0.513165  │
## │ 10  │ 0.116969   │ 0.159177    │ 0.669663  │ 0.162558 │ 0.599571  │</code></pre>
<p>Also, we can select a column by using its name as a symbol or using the “.” operator:</p>
<pre class="julia"><code>## take the column x1 using &quot;.&quot; operator:
foo.x1</code></pre>
<pre><code>## 100-element Array{Float64,1}:
##  0.4970799190412798   
##  0.0018594146093910968
##  0.7084701460167946   
##  0.8066614193596107   
##  0.5613959603948786   
##  0.3033436783236374   
##  0.263182387716427    
##  0.311383585164938    
##  0.14786346664923977  
##  0.11696860984433166  
##  ⋮                    
##  0.017150814528627878 
##  0.263712689738157    
##  0.6664162988052065   
##  0.5429172714275028   
##  0.4858392097193336   
##  0.668850788586848    
##  0.1728882888993606   
##  0.5022878166988076   
##  0.9753435474386369</code></pre>
<pre class="julia"><code>## Take the column using &quot;x1&quot; as a symbol:
foo[:x1]</code></pre>
<pre><code>## 100-element Array{Float64,1}:
##  0.4970799190412798   
##  0.0018594146093910968
##  0.7084701460167946   
##  0.8066614193596107   
##  0.5613959603948786   
##  0.3033436783236374   
##  0.263182387716427    
##  0.311383585164938    
##  0.14786346664923977  
##  0.11696860984433166  
##  ⋮                    
##  0.017150814528627878 
##  0.263712689738157    
##  0.6664162988052065   
##  0.5429172714275028   
##  0.4858392097193336   
##  0.668850788586848    
##  0.1728882888993606   
##  0.5022878166988076   
##  0.9753435474386369</code></pre>
<p>Notice that the return will be an Array. To select one or more column and return
them as a DataFrame type, we use the double brackets syntax:</p>
<pre class="julia"><code>using DataFramesMeta
## take column x1 as DataFrame
@linq foo[[:x1]] |&gt; first(5)</code></pre>
<pre><code>## 5×1 DataFrame
## │ Row │ x1         │
## │     │ Float64    │
## ├─────┼────────────┤
## │ 1   │ 0.49708    │
## │ 2   │ 0.00185941 │
## │ 3   │ 0.70847    │
## │ 4   │ 0.806661   │
## │ 5   │ 0.561396   │</code></pre>
<pre class="julia"><code>## Take column x1 an x2:
@linq foo[[:x1, :x2]] |&gt; first(5)</code></pre>
<pre><code>## 5×2 DataFrame
## │ Row │ x1         │ x2        │
## │     │ Float64    │ Float64   │
## ├─────┼────────────┼───────────┤
## │ 1   │ 0.49708    │ 0.0760758 │
## │ 2   │ 0.00185941 │ 0.227116  │
## │ 3   │ 0.70847    │ 0.270637  │
## │ 4   │ 0.806661   │ 0.325429  │
## │ 5   │ 0.561396   │ 0.987613  │</code></pre>
<p>There are some new things here. The <code>first()</code> function aims to just show the first
lines of our dataset. Similarly, <code>last()</code> performs the same, but showing us the last
lines. Also, you may have noticed the use of the <strong>“|&gt;”</strong> operator. This is the
<strong>pipe</strong> symbol in Julia. If you are familiar with <strong>R</strong> programming language, it
works similarly to the <strong>“%&gt;%”</strong> operator from <em>magrittr</em> package, but with some
limitations. For example, we can not pipe to a specific argument in a
subsequent function, so that’s why the use of <strong><span class="citation">@linq</span></strong> from <strong>DataFramesMeta</strong>
package. For now just take these commands for granted. In another post I will show
how to use the functionalities of the metaprogramming tools for <strong>DataFrames</strong>.</p>
<p>Another trivial task we can perform with column is to add or alter columns in a
DataFrame. For example, let’s create a new column which will be a sequence between
1 and until 100 by 0.5:</p>
<pre class="julia"><code>## To create a sequence, use the function range():
foo[:new_column] = range(1, step = 0.5, length = nrow(foo));
foo[:, :new_column]</code></pre>
<pre><code>## 100-element Array{Float64,1}:
##   1.0
##   1.5
##   2.0
##   2.5
##   3.0
##   3.5
##   4.0
##   4.5
##   5.0
##   5.5
##   ⋮  
##  46.5
##  47.0
##  47.5
##  48.0
##  48.5
##  49.0
##  49.5
##  50.0
##  50.5</code></pre>
<p>We can also add column using the <code>insertcols!()</code> function. The syntax allow us to
specify in which position we want to add the column in the DataFrame:</p>
<pre class="julia"><code>## syntax: insert!(dataset, position, column_name =&gt; array)
insertcols!(foo, 2, :new_colum2 =&gt; range(1, step = 0.5, length = nrow(foo)));
first(foo,</code></pre>
<p>Note the use of the <strong>“!”</strong> in <code>insertcols!()</code> function. This means that the function
is altering the object in memory rather than in a “virtual copy” that later needs
to be assigned to a new variable. This is a behavior that can be used in other function
as well.</p>
<p>Ok… But what if you want to do the opposite? that is, to remove a column?
Well… it is just as easy as to add it. Just use the <code>deletecols!()</code> function:</p>
<pre class="julia"><code>deletecols!(foo, [:new_column, :new_colum2])</code></pre>
<pre><code>## 100×10 DataFrame. Omitted printing of 5 columns
## │ Row │ x1         │ x2          │ x3        │ x4        │ x5        │
## │     │ Float64    │ Float64     │ Float64   │ Float64   │ Float64   │
## ├─────┼────────────┼─────────────┼───────────┼───────────┼───────────┤
## │ 1   │ 0.49708    │ 0.0760758   │ 0.902615  │ 0.266038  │ 0.0543373 │
## │ 2   │ 0.00185941 │ 0.227116    │ 0.328533  │ 0.123489  │ 0.0806307 │
## │ 3   │ 0.70847    │ 0.270637    │ 0.314016  │ 0.144984  │ 0.911408  │
## │ 4   │ 0.806661   │ 0.325429    │ 0.197887  │ 0.654135  │ 0.0131468 │
## │ 5   │ 0.561396   │ 0.987613    │ 0.0988301 │ 0.417581  │ 0.0499511 │
## │ 6   │ 0.303344   │ 0.000183882 │ 0.472595  │ 0.792644  │ 0.63012   │
## │ 7   │ 0.263182   │ 0.386939    │ 0.135905  │ 0.82161   │ 0.243965  │
## ⋮
## │ 93  │ 0.263713   │ 0.552308    │ 0.358334  │ 0.666055  │ 0.41237   │
## │ 94  │ 0.666416   │ 0.10521     │ 0.828499  │ 0.499015  │ 0.290909  │
## │ 95  │ 0.542917   │ 0.414531    │ 0.779626  │ 0.284235  │ 0.944611  │
## │ 96  │ 0.485839   │ 0.0650952   │ 0.514224  │ 0.0459998 │ 0.298542  │
## │ 97  │ 0.668851   │ 0.337354    │ 0.661354  │ 0.544525  │ 0.7073    │
## │ 98  │ 0.172888   │ 0.445677    │ 0.204508  │ 0.330751  │ 0.798409  │
## │ 99  │ 0.502288   │ 0.767121    │ 0.674367  │ 0.476936  │ 0.98405   │
## │ 100 │ 0.975344   │ 0.824484    │ 0.580215  │ 0.0512332 │ 0.0237256 │</code></pre>
<p>Now suppose that you do not want to delete a colum, but just change its name.
For this task, I am afraid there is a very difficult function to remember
the name: <code>rename()</code>. The syntax is as follows:</p>
<pre class="julia"><code>## rename(dataFrame, :old_name =&gt; :new_name)
rename(foo, :x1 =&gt; :A1, :x2 =&gt; :A2)</code></pre>
<pre><code>## 100×10 DataFrame. Omitted printing of 5 columns
## │ Row │ A1         │ A2          │ x3        │ x4        │ x5        │
## │     │ Float64    │ Float64     │ Float64   │ Float64   │ Float64   │
## ├─────┼────────────┼─────────────┼───────────┼───────────┼───────────┤
## │ 1   │ 0.49708    │ 0.0760758   │ 0.902615  │ 0.266038  │ 0.0543373 │
## │ 2   │ 0.00185941 │ 0.227116    │ 0.328533  │ 0.123489  │ 0.0806307 │
## │ 3   │ 0.70847    │ 0.270637    │ 0.314016  │ 0.144984  │ 0.911408  │
## │ 4   │ 0.806661   │ 0.325429    │ 0.197887  │ 0.654135  │ 0.0131468 │
## │ 5   │ 0.561396   │ 0.987613    │ 0.0988301 │ 0.417581  │ 0.0499511 │
## │ 6   │ 0.303344   │ 0.000183882 │ 0.472595  │ 0.792644  │ 0.63012   │
## │ 7   │ 0.263182   │ 0.386939    │ 0.135905  │ 0.82161   │ 0.243965  │
## ⋮
## │ 93  │ 0.263713   │ 0.552308    │ 0.358334  │ 0.666055  │ 0.41237   │
## │ 94  │ 0.666416   │ 0.10521     │ 0.828499  │ 0.499015  │ 0.290909  │
## │ 95  │ 0.542917   │ 0.414531    │ 0.779626  │ 0.284235  │ 0.944611  │
## │ 96  │ 0.485839   │ 0.0650952   │ 0.514224  │ 0.0459998 │ 0.298542  │
## │ 97  │ 0.668851   │ 0.337354    │ 0.661354  │ 0.544525  │ 0.7073    │
## │ 98  │ 0.172888   │ 0.445677    │ 0.204508  │ 0.330751  │ 0.798409  │
## │ 99  │ 0.502288   │ 0.767121    │ 0.674367  │ 0.476936  │ 0.98405   │
## │ 100 │ 0.975344   │ 0.824484    │ 0.580215  │ 0.0512332 │ 0.0237256 │</code></pre>
<p>We could also add the <strong>“!”</strong> to the <code>rename()</code> function to alter the DataFrame
in memory.</p>
</div>
<div id="lets-talk-about-missing-values" class="section level2">
<h2>Let’s talk about missing values:</h2>
<p>Missing values are represented in Julia with <strong>missing</strong> value. When an array
contains missing values, it automatically creates an appropriate union type:</p>
<pre class="julia"><code>x = [1.0, 2.0, missing]</code></pre>
<pre><code>## 3-element Array{Union{Missing, Float64},1}:
##  1.0     
##  2.0     
##   missing</code></pre>
<pre class="julia"><code>typeof(x)</code></pre>
<pre><code>## Array{Union{Missing, Float64},1}</code></pre>
<pre class="julia"><code>typeof.(x)</code></pre>
<pre><code>## 3-element Array{DataType,1}:
##  Float64
##  Float64
##  Missing</code></pre>
<p>To check if a particular element in an array is missing, we use the <code>ismissing()</code>
function:</p>
<pre class="julia"><code>ismissing.([1.0, 2.0, missing])</code></pre>
<pre><code>## 3-element BitArray{1}:
##  false
##  false
##   true</code></pre>
<p>It is important to notice that <em>missing</em> comparison produces <em>missing</em> as a result:</p>
<pre class="julia"><code>missing == missing</code></pre>
<p><strong>isequal</strong> and <strong>===</strong> can be used to produce the results of type <em>Bool</em>:</p>
<pre class="julia"><code>isequal(missing, missing)</code></pre>
<pre><code>## true</code></pre>
<pre class="julia"><code>missing === missing</code></pre>
<pre><code>## true</code></pre>
<p>Other functions are available to work with missing values. For instance, suppose
we want an array with only non-missing values, we use the <code>skipmissing()</code> function:</p>
<pre class="julia"><code>x |&gt; skipmissing |&gt; collect</code></pre>
<pre><code>## 2-element Array{Float64,1}:
##  1.0
##  2.0</code></pre>
<p>Here, we use the <code>collect()</code> function as the <code>skipmissing()</code> returns an iterator.</p>
<p>To replace the missing values with some other value we can use the
<code>Missings.replace()</code> function. For example, suppose we want to change the missing
values by <em>NaN</em>:</p>
<pre class="julia"><code>Missings.replace(x, NaN) |&gt; collect</code></pre>
<pre><code>## 3-element Array{Float64,1}:
##    1.0
##    2.0
##  NaN</code></pre>
<p>We also can use use other ways to perform the same operation:</p>
<pre class="julia"><code>## Using coalesce() function:
coalesce.(x, NaN)</code></pre>
<pre><code>## 3-element Array{Float64,1}:
##    1.0
##    2.0
##  NaN</code></pre>
<pre class="julia"><code>## Using recode() function:
recode(x, missing =&gt; NaN)</code></pre>
<pre><code>## 3-element Array{Float64,1}:
##    1.0
##    2.0
##  NaN</code></pre>
<p>Until now, we have only talked about missing values in arrays. But what about missing
values in DataFrames? To start, let’s create a DataFrame with some missing values:</p>
<pre class="julia"><code>x = DataFrame(A = [1, missing, 3, 4], B = [&quot;A&quot;, &quot;B&quot;, missing, &quot;C&quot;])</code></pre>
<pre><code>## 4×2 DataFrame
## │ Row │ A       │ B       │
## │     │ Int64⍰  │ String⍰ │
## ├─────┼─────────┼─────────┤
## │ 1   │ 1       │ A       │
## │ 2   │ missing │ B       │
## │ 3   │ 3       │ missing │
## │ 4   │ 4       │ C       │</code></pre>
<p>For some analysis, we would want only the rows with non-missing values. One way
to achieve this is making use of the <code>completecases()</code> function:</p>
<pre class="julia"><code>x[completecases(x), :]</code></pre>
<pre><code>## 2×2 DataFrame
## │ Row │ A      │ B       │
## │     │ Int64⍰ │ String⍰ │
## ├─────┼────────┼─────────┤
## │ 1   │ 1      │ A       │
## │ 2   │ 4      │ C       │</code></pre>
<p>The <code>completecases()</code> function returns an boolean array with value <em>true</em> for
rows that have non-missing values and <em>false</em> otherwise. For those who are familiar
with <strong>R</strong>, this is the same behavior as the <code>complete.cases()</code> function from <em>stats</em> package.</p>
<p>Another option to return the rows with non-missing values of a DataFrame in Julia
is to use the <code>dropmissing()</code> function:</p>
<pre class="julia"><code>dropmissing(x)</code></pre>
<pre><code>## 2×2 DataFrame
## │ Row │ A      │ B       │
## │     │ Int64⍰ │ String⍰ │
## ├─────┼────────┼─────────┤
## │ 1   │ 1      │ A       │
## │ 2   │ 4      │ C       │</code></pre>
<p>and again, for <strong>R</strong> users is the same behaviro as <em>na.omit()</em> function.</p>
</div>
<div id="merging-dataframes" class="section level2">
<h2>Merging DataFrames:</h2>
<p>Often, we need to combine two or more DataFrames together based on some common
column(s) among them. For example, suppose we have two DataFrames:</p>
<pre class="julia"><code>df1 = DataFrame(x = 1:3, y = 4:6)</code></pre>
<pre><code>## 3×2 DataFrame
## │ Row │ x     │ y     │
## │     │ Int64 │ Int64 │
## ├─────┼───────┼───────┤
## │ 1   │ 1     │ 4     │
## │ 2   │ 2     │ 5     │
## │ 3   │ 3     │ 6     │</code></pre>
<pre class="julia"><code>df2 = DataFrame(x = 1:3, z = &#39;d&#39;:&#39;f&#39;, new = 11:13)</code></pre>
<pre><code>## 3×3 DataFrame
## │ Row │ x     │ z    │ new   │
## │     │ Int64 │ Char │ Int64 │
## ├─────┼───────┼──────┼───────┤
## │ 1   │ 1     │ &#39;d&#39;  │ 11    │
## │ 2   │ 2     │ &#39;e&#39;  │ 12    │
## │ 3   │ 3     │ &#39;f&#39;  │ 13    │</code></pre>
<p>which have the column <em>x</em> in common. To merge these two tables, we use the
<code>join()</code> function:</p>
<pre class="julia"><code>join(df1, df2, on = :x)</code></pre>
<pre><code>## 3×4 DataFrame
## │ Row │ x     │ y     │ z    │ new   │
## │     │ Int64 │ Int64 │ Char │ Int64 │
## ├─────┼───────┼───────┼──────┼───────┤
## │ 1   │ 1     │ 4     │ &#39;d&#39;  │ 11    │
## │ 2   │ 2     │ 5     │ &#39;e&#39;  │ 12    │
## │ 3   │ 3     │ 6     │ &#39;f&#39;  │ 13    │</code></pre>
<p>That’s it!! We merge our DataFrames altogether. But that’s the default behavior of
the function. There is more to explore. Essentially, <code>join()</code> takes 4 arguments:</p>
<ul>
<li>DataFrame 1</li>
<li>DataFrame 2</li>
<li>on = the column(s) to be the key in merging;</li>
<li>kind = type of the merge (left, right, inner, outer, …)</li>
</ul>
<p>The <em>kind</em> argument specifies the type of join we are interested in performing.
The definition of each one is as follows:</p>
<ul>
<li><p><em>Inner</em>: The output contains rows for values of the key that exist
in <strong>BOTH</strong> the first (left) and second (right) arguments to
join;</p></li>
<li><p><em>Left</em>: The output contains rows for values of the key that exist in
the first (left) argument to join, whether or not that value
exists in the second (right) argument;</p></li>
<li><p><em>Right</em>: The output contains rows for values of the key that exist in
the second (right) argument to join, whether or not that
value exists in the first (left) argument;</p></li>
<li><p><em>Outer</em>: The output contains rows for values of the key that exist in
the first (left) <strong>OR</strong> second (right) argument to join;</p></li>
</ul>
<p>and here are the “<em>strange</em>” ones:</p>
<ul>
<li><p><em>Semi</em>: Like an inner join, but output is restricted to columns from
the first (left) argument to join;</p></li>
<li><p><em>Anti</em>: The output contains rows for values of the key that exist in
the first (left) but <strong>NOT</strong> in the second (right) argument to
join. As with semi joins, output is restricted to columns
from the first (left) argument.</p></li>
</ul>
<p>If you are familiar with <em>SQL</em> or with the join functions from <em>dplyr</em> package in <strong>R</strong>,
it is the same concept.</p>
<p>To illustrate how the different kind of joins work, let’s create more DataFrames
to demonstrate each type of join:</p>
<pre class="julia"><code>Names = DataFrame(ID = [20, 40], Name = [&quot;John Doe&quot;, &quot;Jane Doe&quot;])</code></pre>
<pre><code>## 2×2 DataFrame
## │ Row │ ID    │ Name     │
## │     │ Int64 │ String   │
## ├─────┼───────┼──────────┤
## │ 1   │ 20    │ John Doe │
## │ 2   │ 40    │ Jane Doe │</code></pre>
<pre class="julia"><code>jobs = DataFrame(ID = [20, 60], Job = [&quot;Lawyer&quot;, &quot;Astronaut&quot;])</code></pre>
<pre><code>## 2×2 DataFrame
## │ Row │ ID    │ Job       │
## │     │ Int64 │ String    │
## ├─────┼───────┼───────────┤
## │ 1   │ 20    │ Lawyer    │
## │ 2   │ 60    │ Astronaut │</code></pre>
<p>In the Names and jobs DataFrame, we have the ID column as the key to perform the
join. But notice that the ID values are not equal between the DataFrames. Now
let’s perform the joins:</p>
<pre class="julia"><code>join(Names, jobs, on = :ID, kind = :inner)</code></pre>
<pre><code>## 1×3 DataFrame
## │ Row │ ID    │ Name     │ Job    │
## │     │ Int64 │ String   │ String │
## ├─────┼───────┼──────────┼────────┤
## │ 1   │ 20    │ John Doe │ Lawyer │</code></pre>
<pre class="julia"><code>join(Names, jobs, on = :ID, kind = :left)</code></pre>
<pre><code>## 2×3 DataFrame
## │ Row │ ID    │ Name     │ Job     │
## │     │ Int64 │ String   │ String⍰ │
## ├─────┼───────┼──────────┼─────────┤
## │ 1   │ 20    │ John Doe │ Lawyer  │
## │ 2   │ 40    │ Jane Doe │ missing │</code></pre>
<pre class="julia"><code>join(Names, jobs, on = :ID, kind = :right)</code></pre>
<pre><code>## 2×3 DataFrame
## │ Row │ ID    │ Name     │ Job       │
## │     │ Int64 │ String⍰  │ String    │
## ├─────┼───────┼──────────┼───────────┤
## │ 1   │ 20    │ John Doe │ Lawyer    │
## │ 2   │ 60    │ missing  │ Astronaut │</code></pre>
<pre class="julia"><code>join(Names, jobs, on = :ID, kind = :outer)</code></pre>
<pre><code>## 3×3 DataFrame
## │ Row │ ID    │ Name     │ Job       │
## │     │ Int64 │ String⍰  │ String⍰   │
## ├─────┼───────┼──────────┼───────────┤
## │ 1   │ 20    │ John Doe │ Lawyer    │
## │ 2   │ 40    │ Jane Doe │ missing   │
## │ 3   │ 60    │ missing  │ Astronaut │</code></pre>
<p><em>Semi</em> and <em>anti</em> join have a more uncommon behavior. Semi join returns the rows
from the left which <strong>DOES MATCHES</strong> with the ID from the right:</p>
<pre class="julia"><code>join(Names, jobs, on = :ID, kind = :semi)</code></pre>
<pre><code>## 1×2 DataFrame
## │ Row │ ID    │ Name     │
## │     │ Int64 │ String   │
## ├─────┼───────┼──────────┤
## │ 1   │ 20    │ John Doe │</code></pre>
<p>Anti join returns the rows from the left which <strong>DOES NOT MATCH</strong> with
the ID from the right</p>
<pre class="julia"><code>join(Names, jobs, on = :ID, kind = :anti)</code></pre>
<pre><code>## 1×2 DataFrame
## │ Row │ ID    │ Name     │
## │     │ Int64 │ String   │
## ├─────┼───────┼──────────┤
## │ 1   │ 40    │ Jane Doe │</code></pre>
</div>
<div id="split-apply-combine" class="section level2">
<h2>Split-Apply-Combine:</h2>
<p>Some common tasks involve split the data into groups, applying some function
to each of these groups and gather the results to analyze later on. This is the
split-apply-combine strategy described in the paper “<a href="https://www.jstatsoft.org/article/view/v040i01">The Split-Apply-Combine Strategy for Data analysis</a>” written by Hadley Wickham, creator
of many <strong>R</strong> packages, including <em>ggplot2</em> and <em>dplyr</em>.</p>
<p>The DataFrames package in Julia supports the Split-Apply-Combine strategy
through the <code>by()</code> function, which takes three arguments:</p>
<ul>
<li>DataFrame;</li>
<li>one or more column names to split on;</li>
<li>a function or expression to apply to each subset;</li>
</ul>
<p>To illustrate its usage, let’s make use of the <em>RDatasets</em> package, which gives
access to some preloaded well known datasets from R packages.</p>
<pre class="julia"><code>using RDatasets
foo = dataset(&quot;datasets&quot;, &quot;iris&quot;);
first(foo, 5)</code></pre>
<pre><code>## 5×5 DataFrame
## │ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species      │
## │     │ Float64     │ Float64    │ Float64     │ Float64    │ Categorical… │
## ├─────┼─────────────┼────────────┼─────────────┼────────────┼──────────────┤
## │ 1   │ 5.1         │ 3.5        │ 1.4         │ 0.2        │ setosa       │
## │ 2   │ 4.9         │ 3.0        │ 1.4         │ 0.2        │ setosa       │
## │ 3   │ 4.7         │ 3.2        │ 1.3         │ 0.2        │ setosa       │
## │ 4   │ 4.6         │ 3.1        │ 1.5         │ 0.2        │ setosa       │
## │ 5   │ 5.0         │ 3.6        │ 1.4         │ 0.2        │ setosa       │</code></pre>
<p>A trivial task is to do is to find how many of each “Species” there are in the
dataset. One way to do this is to apply the split-apply-combine strategy: <strong>split</strong>
the data into the <em>species</em> column, <strong>apply</strong> the <em>nrow()</em> function to this
splitted dataset, and <strong>combine</strong> the results:</p>
<pre class="julia"><code>## Syntax: by(dataset, :name_column_to_split, name_function)
by(foo, :Species, nrow)</code></pre>
<pre><code>## 3×2 DataFrame
## │ Row │ Species      │ x1    │
## │     │ Categorical… │ Int64 │
## ├─────┼──────────────┼───────┤
## │ 1   │ setosa       │ 50    │
## │ 2   │ versicolor   │ 50    │
## │ 3   │ virginica    │ 50    │</code></pre>
<p>We can also make use of <strong>anonymous</strong> function:</p>
<pre class="julia"><code>by(foo, :Species, x -&gt; DataFrame(N = nrow(x)))</code></pre>
<pre><code>## 3×2 DataFrame
## │ Row │ Species      │ N     │
## │     │ Categorical… │ Int64 │
## ├─────┼──────────────┼───────┤
## │ 1   │ setosa       │ 50    │
## │ 2   │ versicolor   │ 50    │
## │ 3   │ virginica    │ 50    │</code></pre>
<p>One of the advantages of using anonymous function inside the <code>by()</code> function is
that we can format the resulted output and apply as many function as we want:</p>
<pre class="julia"><code>## Applying the count, mean and standard deviation function:
by(foo, :Species, x -&gt; DataFrame(N = nrow(x),
                                 avg_PetalLength = mean(x[:PetalLength]),
                                 std_PetalWidth = std(x[:PetalWidth])))</code></pre>
<pre><code>## 3×4 DataFrame
## │ Row │ Species      │ N     │ avg_PetalLength │ std_PetalWidth │
## │     │ Categorical… │ Int64 │ Float64         │ Float64        │
## ├─────┼──────────────┼───────┼─────────────────┼────────────────┤
## │ 1   │ setosa       │ 50    │ 1.462           │ 0.105386       │
## │ 2   │ versicolor   │ 50    │ 4.26            │ 0.197753       │
## │ 3   │ virginica    │ 50    │ 5.552           │ 0.27465        │</code></pre>
<p>Another way to use the Split-Apply-Combine strategy is implementing the
<code>aggregate()</code> function, which also takes three arguments:</p>
<ul>
<li>DataFrame;</li>
<li>one or more column names to split on;</li>
<li>one or more function to be applied <strong>ON THE COLUMNS NOT USED TO SPLIT</strong>.</li>
</ul>
<p>The difference between <code>by()</code> and <code>aggregate()</code> function is that in the
latter, the function(s) will be applied to each column not used in
the split part.</p>
<p>For instance, let’s say you want the average of each colum for each <em>Species</em>.
Instead of using <code>by()</code> with an anonymous function and writing the name of all columns
we can do:</p>
<pre class="julia"><code>aggregate(foo, :Species, [mean])</code></pre>
<pre><code>## 3×5 DataFrame. Omitted printing of 1 columns
## │ Row │ Species      │ SepalLength_mean │ SepalWidth_mean │ PetalLength_mean │
## │     │ Categorical… │ Float64          │ Float64         │ Float64          │
## ├─────┼──────────────┼──────────────────┼─────────────────┼──────────────────┤
## │ 1   │ setosa       │ 5.006            │ 3.428           │ 1.462            │
## │ 2   │ versicolor   │ 5.936            │ 2.77            │ 4.26             │
## │ 3   │ virginica    │ 6.588            │ 2.974           │ 5.552            │</code></pre>
<p>Note that Julia only display output that fits the screen. Pay
attention to the message “<em>Omitted printing of 1 columns</em>”. To
overcome this, use the <code>show()</code> as advised before.</p>
</div>
</div>
<div id="reading-and-writting-csv-files" class="section level1">
<h1>Reading and Writting CSV files:</h1>
<p>Last but not least, let’s see how to read and write CSV files into/from Julia.
Although this is not exactly handled by the <em>DataFrames</em> package, the task of
reading/writing CSV files are so natural when working with DataFrame that I will
show you the basics.</p>
<p>To read/write CSV files, we use the <strong>CSV</strong> package. To demonstrate its usage,
let’s work with the iris dataset and write a CSV file to a local computer. Then,
we read it back.</p>
<p>So, first we are going to write the <em>foo</em> object (which contains the <em>iris</em> dataset)
to a CSV file. To do this we will use the <code>CSV.write()</code> function. Some useful
arguments in CSV.write are:</p>
<ul>
<li><em>delim</em> : the file’s delimeter. Default ‘,’.</li>
<li><em>header</em> : boolean whether to write the colnames from source;</li>
<li><em>colnames</em> : provide colnames to be written;</li>
<li><em>append</em> : bool to indicate if it to append data;</li>
<li><em>missingstring</em> : string that indicates how missing values will be represented.</li>
</ul>
<pre class="julia"><code>using CSV
CSV.write(&quot;./iris.csv&quot;, foo, missingsstring = &quot;NA&quot;)</code></pre>
<pre><code>## &quot;./iris.csv&quot;</code></pre>
<p>To read a CSV file, we use the <code>CSV.read()</code>. Some useful arguments are:</p>
<ul>
<li><em>delim</em> : a Char or String that indicates how columns are delimited in a file
file’s delimeter. Default ‘,’;</li>
<li><em>decimal</em> : a Char indicating how decimals are separated in
floats. Default ‘.’ ;</li>
<li><em>limit</em> : indicates the total number of rows to read;</li>
<li><em>header</em> : provide manually the names of the columns.</li>
<li><em>types</em> : a Vector or Dict of types to be used for column types.</li>
</ul>
<pre class="julia"><code>iris = CSV.read(&quot;./iris.csv&quot;)</code></pre>
<pre><code>## 150×5 DataFrame
## │ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species   │
## │     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ String⍰   │
## ├─────┼─────────────┼────────────┼─────────────┼────────────┼───────────┤
## │ 1   │ 5.1         │ 3.5        │ 1.4         │ 0.2        │ setosa    │
## │ 2   │ 4.9         │ 3.0        │ 1.4         │ 0.2        │ setosa    │
## │ 3   │ 4.7         │ 3.2        │ 1.3         │ 0.2        │ setosa    │
## │ 4   │ 4.6         │ 3.1        │ 1.5         │ 0.2        │ setosa    │
## │ 5   │ 5.0         │ 3.6        │ 1.4         │ 0.2        │ setosa    │
## │ 6   │ 5.4         │ 3.9        │ 1.7         │ 0.4        │ setosa    │
## │ 7   │ 4.6         │ 3.4        │ 1.4         │ 0.3        │ setosa    │
## ⋮
## │ 143 │ 5.8         │ 2.7        │ 5.1         │ 1.9        │ virginica │
## │ 144 │ 6.8         │ 3.2        │ 5.9         │ 2.3        │ virginica │
## │ 145 │ 6.7         │ 3.3        │ 5.7         │ 2.5        │ virginica │
## │ 146 │ 6.7         │ 3.0        │ 5.2         │ 2.3        │ virginica │
## │ 147 │ 6.3         │ 2.5        │ 5.0         │ 1.9        │ virginica │
## │ 148 │ 6.5         │ 3.0        │ 5.2         │ 2.0        │ virginica │
## │ 149 │ 6.2         │ 3.4        │ 5.4         │ 2.3        │ virginica │
## │ 150 │ 5.9         │ 3.0        │ 5.1         │ 1.8        │ virginica │</code></pre>
<p>It is important to note that when loading in a DataFrame from a CSV, all columns
allow Missing by default.</p>
<p>This is the basics of reading/writting CSV files in Julia. To get more details
refers to the <a href="http://juliadata.github.io/CSV.jl/latest/#High-level-interface-1">official documentation</a>.</p>
</div>
<div id="conclusion" class="section level1">
<h1>Conclusion:</h1>
<p>This post was a very small introduction to the <strong>DataFrames</strong> packages in Julia.
After reading this post you will be able to read CSV datasets and perform some
tasks with the data at hand.</p>
<p>In the following posts, we will explore more advanced tricks to perform data
wrangling and exploratory data analysis. At each step we are going to build
knowledge to completely use Julia to perform data analysis for any problem that
you might face.</p>
</div>

            </div>
            
            <div class="post-comments">
                
            </div>
            
            <div class="push"></div>
        </div>
        <footer class="footer text-center">
<p>Copyright &copy; 2019 Mr Farias -
<span class="credit">
	Powered by
	<a target="_blank" href="https://gohugo.io">Hugo</a>
	and
	<a target="_blank" href="https://github.com/LordMathis/hugo-theme-nix/">Nix</a> theme.
</span>
</p>
</footer>

    </body>
