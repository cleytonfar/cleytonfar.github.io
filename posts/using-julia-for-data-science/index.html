<!DOCTYPE html>
<html>

    <head>
        <title> Using Julia for Data Science &middot; Cleyton Farias </title>

        <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.53" />


<script   src="https://code.jquery.com/jquery-3.1.1.min.js"   integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="   crossorigin="anonymous"></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">


<link rel="stylesheet" href="/css/nix.css">



<link rel="shortcut icon" href="/data.png">



<link href="https://fonts.googleapis.com/css?family=Inconsolata%7COpen+Sans%7CConcert+One" rel="stylesheet">




    </head>

    <body>
        <header>
<nav class="navbar navbar-default navbar-fixed-top navbar-inverse font-header">
	<div class="container-fluid">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse-1" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" id="green-terminal" href=/>cleyton@farias ~ $</a>
		</div>

		
		<div class="collapse navbar-collapse" id="navbar-collapse-1">
			<ul class="nav navbar-nav navbar-right">
				<li>
					<a href="/">/home/cleyton</a>
				</li>
				
				
				<li class="dropdown">
                    
            		<a href="/research/">~/research</a>
            		
        		</li>
        		
				
				<li class="dropdown">
                    
            		<a href="/talks/">~/talks</a>
            		
        		</li>
        		
				
				<li class="dropdown">
                    
            		<a href="/posts/">~/posts</a>
            		
        		</li>
        		
				
				<li class="dropdown">
                    
            		<a href="/vitae/">~/vitae</a>
            		
        		</li>
        		

			</ul>
		</div>
	</div>
</nav>
</header>

        <div class="container wrapper">
            <h1><a href="/posts/using-julia-for-data-science/">Using Julia for Data Science</a></h1>
            <span class="post-date">Jan 23, 2019 </span>
            <div class="post-content">
                


<p>This a quick introduction to the Julia programming language
and will be presented to you how you can work rightaway with datasets with Julia.</p>
<div id="why-julia" class="section level1">
<h1>Why Julia?</h1>
<p>Julia is a high level programming language released in 2012 by a team of MIT
researchers. Since its beginning, the aim was to solve the so called two-language
programing problem: easy to use functionalities of interpretable languages
(Python, R, Matlab) vs high performance of compiled languages (C, C++, Fortran).</p>
<p>Hence, Julia was born. Combining the JIT (Just In Time) compiler and
Julia’s multiple-dispatch system plus the fact that its codebase is written entirely in
native language, Julia gives birth to the popular phrase in the community:</p>
<p><strong>“Walks like Python, runs like C.”</strong></p>
</div>
<div id="introduction-to-dataframes-in-julia" class="section level1">
<h1>Introduction to DataFrames in Julia</h1>
<p>In Julia, tablular data is handled using the <strong>DataFrames</strong> package. Other packages
are commonly used to read/write data into/from Julia such as <strong>CSV</strong>.</p>
<p>A data frame is created using the <code>DataFrame()</code> function:</p>
<pre class="julia"><code>using DataFrames
foo = DataFrame();
foo </code></pre>
<pre><code>## 0×0 DataFrame</code></pre>
<p>To use the functionalities of the package, let’s create some random data. I will
use the <code>rand()</code> function to generate random numbers to create an array 100 x 10
and convert it to a data frame:</p>
<pre class="julia"><code>foo = DataFrame(rand(100, 10));
foo </code></pre>
<pre><code>## 100×10 DataFrame. Omitted printing of 5 columns
## │ Row │ x1         │ x2        │ x3        │ x4        │ x5         │
## │     │ Float64    │ Float64   │ Float64   │ Float64   │ Float64    │
## ├─────┼────────────┼───────────┼───────────┼───────────┼────────────┤
## │ 1   │ 0.508564   │ 0.79816   │ 0.724948  │ 0.427013  │ 0.164095   │
## │ 2   │ 0.00486372 │ 0.885084  │ 0.33327   │ 0.647139  │ 0.66389    │
## │ 3   │ 0.759279   │ 0.260589  │ 0.973213  │ 0.802042  │ 0.796163   │
## │ 4   │ 0.019347   │ 0.420296  │ 0.654524  │ 0.782539  │ 0.9021     │
## │ 5   │ 0.298613   │ 0.521171  │ 0.922536  │ 0.0624479 │ 0.157143   │
## │ 6   │ 0.434307   │ 0.243373  │ 0.949971  │ 0.841466  │ 0.316669   │
## │ 7   │ 0.649945   │ 0.286611  │ 0.173691  │ 0.093866  │ 0.00910509 │
## ⋮
## │ 93  │ 0.647089   │ 0.634504  │ 0.606423  │ 0.799559  │ 0.583944   │
## │ 94  │ 0.895887   │ 0.0981045 │ 0.17749   │ 0.914557  │ 0.0330169  │
## │ 95  │ 0.775965   │ 0.718786  │ 0.229372  │ 0.164901  │ 0.89619    │
## │ 96  │ 0.759445   │ 0.279651  │ 0.184873  │ 0.0181733 │ 0.16676    │
## │ 97  │ 0.484503   │ 0.31399   │ 0.0153769 │ 0.723479  │ 0.736016   │
## │ 98  │ 0.242222   │ 0.643847  │ 0.0524266 │ 0.152642  │ 0.886782   │
## │ 99  │ 0.566356   │ 0.0976754 │ 0.856145  │ 0.988628  │ 0.888342   │
## │ 100 │ 0.301572   │ 0.746761  │ 0.224298  │ 0.678956  │ 0.361499   │</code></pre>
<p>To get the dimension of a data frame, we can use the <code>size()</code> function. Also,
<code>nrow()</code> and <code>ncol()</code> are available to get the number of rows and columns:</p>
<pre class="julia"><code>size(foo)</code></pre>
<pre><code>## (100, 10)</code></pre>
<pre class="julia"><code>nrow(foo)</code></pre>
<pre><code>## 100</code></pre>
<pre class="julia"><code>ncol(foo)</code></pre>
<pre><code>## 10</code></pre>
<p>To get the column names, we use the <code>names()</code> function:</p>
<pre class="julia"><code>names(foo)</code></pre>
<pre><code>## 10-element Array{Symbol,1}:
##  :x1 
##  :x2 
##  :x3 
##  :x4 
##  :x5 
##  :x6 
##  :x7 
##  :x8 
##  :x9 
##  :x10</code></pre>
<p>To get a summary of the dataset in general, we can use the function <code>describe()</code>:</p>
<pre class="julia"><code>describe(foo)</code></pre>
<pre><code>## 10×8 DataFrame. Omitted printing of 2 columns
## │ Row │ variable │ mean     │ min         │ median   │ max      │ nunique │
## │     │ Symbol   │ Float64  │ Float64     │ Float64  │ Float64  │ Nothing │
## ├─────┼──────────┼──────────┼─────────────┼──────────┼──────────┼─────────┤
## │ 1   │ x1       │ 0.517408 │ 0.00352578  │ 0.52376  │ 0.997315 │         │
## │ 2   │ x2       │ 0.466956 │ 0.023083    │ 0.400233 │ 0.99825  │         │
## │ 3   │ x3       │ 0.511119 │ 0.00931805  │ 0.537964 │ 0.999603 │         │
## │ 4   │ x4       │ 0.520018 │ 0.00852001  │ 0.554502 │ 0.998958 │         │
## │ 5   │ x5       │ 0.46243  │ 0.00247209  │ 0.468213 │ 0.993678 │         │
## │ 6   │ x6       │ 0.50738  │ 0.0024173   │ 0.517936 │ 0.99837  │         │
## │ 7   │ x7       │ 0.567619 │ 0.000171109 │ 0.563367 │ 0.987788 │         │
## │ 8   │ x8       │ 0.502244 │ 0.00944168  │ 0.496345 │ 0.99794  │         │
## │ 9   │ x9       │ 0.502561 │ 0.00072322  │ 0.463291 │ 0.999251 │         │
## │ 10  │ x10      │ 0.510987 │ 0.00920505  │ 0.532866 │ 0.998502 │         │</code></pre>
<p>Note that there is a message indicating the omission of two columns. This is the
default behavior of Julia. To avoid this feature, we use the <code>show()</code> function
as follows:</p>
<pre><code>show(describe(foo), allcols = true)</code></pre>
<div id="manipulating-rows" class="section level2">
<h2>Manipulating Rows:</h2>
<p>Subset rows in Julia can be a little odd, but once you get used to, it becomes
more logical. For example, suppose we want the rows where x1 is above the average.
We could this as follows:</p>
<pre class="julia"><code>## Loading the Statistics package:
using Statistics

## Creating the conditional:
cond01 = foo[:x1] .&gt;= mean(foo[:x1]);

## Subsetting:
foo[cond01, :] |&gt; head</code></pre>
<pre><code>## 6×10 DataFrame. Omitted printing of 4 columns
## │ Row │ x1       │ x2        │ x3        │ x4       │ x5         │ x6        │
## │     │ Float64  │ Float64   │ Float64   │ Float64  │ Float64    │ Float64   │
## ├─────┼──────────┼───────────┼───────────┼──────────┼────────────┼───────────┤
## │ 1   │ 0.759279 │ 0.260589  │ 0.973213  │ 0.802042 │ 0.796163   │ 0.0726998 │
## │ 2   │ 0.649945 │ 0.286611  │ 0.173691  │ 0.093866 │ 0.00910509 │ 0.307678  │
## │ 3   │ 0.859137 │ 0.40535   │ 0.0773852 │ 0.806471 │ 0.586517   │ 0.612467  │
## │ 4   │ 0.982966 │ 0.0728624 │ 0.756845  │ 0.149343 │ 0.304951   │ 0.716904  │
## │ 5   │ 0.870577 │ 0.305001  │ 0.262877  │ 0.486184 │ 0.993678   │ 0.279673  │
## │ 6   │ 0.944028 │ 0.83349   │ 0.230722  │ 0.235556 │ 0.916392   │ 0.697508  │</code></pre>
<p>What if we want two conditionals? For example, we want the same condition as before
and/or the rows where x2 is greater than or equal its average? Now things
become trickier. Let’s check how we would do this:</p>
<pre class="julia"><code>## Creating the second conditional:
cond02 = foo[:x2] .&gt;= mean(foo[:x2]);

## Subsetting cond01 AND cond02:
foo[.&amp;(cond01, cond02), :]</code></pre>
<pre><code>## 24×10 DataFrame. Omitted printing of 4 columns
## │ Row │ x1       │ x2       │ x3        │ x4        │ x5        │ x6        │
## │     │ Float64  │ Float64  │ Float64   │ Float64   │ Float64   │ Float64   │
## ├─────┼──────────┼──────────┼───────────┼───────────┼───────────┼───────────┤
## │ 1   │ 0.944028 │ 0.83349  │ 0.230722  │ 0.235556  │ 0.916392  │ 0.697508  │
## │ 2   │ 0.934903 │ 0.738854 │ 0.509527  │ 0.987305  │ 0.71851   │ 0.71118   │
## │ 3   │ 0.914597 │ 0.691625 │ 0.984924  │ 0.648461  │ 0.0840993 │ 0.463151  │
## │ 4   │ 0.619366 │ 0.564372 │ 0.272303  │ 0.852711  │ 0.287101  │ 0.355596  │
## │ 5   │ 0.793792 │ 0.512583 │ 0.956608  │ 0.0321743 │ 0.539281  │ 0.342549  │
## │ 6   │ 0.682595 │ 0.731334 │ 0.990678  │ 0.407722  │ 0.229568  │ 0.0024173 │
## │ 7   │ 0.705151 │ 0.968423 │ 0.62266   │ 0.696483  │ 0.899218  │ 0.124958  │
## ⋮
## │ 17  │ 0.748152 │ 0.705784 │ 0.0570891 │ 0.498016  │ 0.114746  │ 0.215977  │
## │ 18  │ 0.892033 │ 0.87243  │ 0.691372  │ 0.647882  │ 0.466287  │ 0.416782  │
## │ 19  │ 0.723011 │ 0.598063 │ 0.635263  │ 0.385299  │ 0.860482  │ 0.83328   │
## │ 20  │ 0.961347 │ 0.710643 │ 0.0636946 │ 0.829527  │ 0.390623  │ 0.547419  │
## │ 21  │ 0.565419 │ 0.490902 │ 0.946227  │ 0.675017  │ 0.59165   │ 0.306185  │
## │ 22  │ 0.80098  │ 0.99825  │ 0.683375  │ 0.800416  │ 0.122661  │ 0.12856   │
## │ 23  │ 0.647089 │ 0.634504 │ 0.606423  │ 0.799559  │ 0.583944  │ 0.417589  │
## │ 24  │ 0.775965 │ 0.718786 │ 0.229372  │ 0.164901  │ 0.89619   │ 0.301304  │</code></pre>
<pre class="julia"><code>## Subsetting cond01 OR cond02:
foo[.|(cond01, cond02), :]</code></pre>
<pre><code>## 72×10 DataFrame. Omitted printing of 5 columns
## │ Row │ x1         │ x2        │ x3        │ x4        │ x5         │
## │     │ Float64    │ Float64   │ Float64   │ Float64   │ Float64    │
## ├─────┼────────────┼───────────┼───────────┼───────────┼────────────┤
## │ 1   │ 0.508564   │ 0.79816   │ 0.724948  │ 0.427013  │ 0.164095   │
## │ 2   │ 0.00486372 │ 0.885084  │ 0.33327   │ 0.647139  │ 0.66389    │
## │ 3   │ 0.759279   │ 0.260589  │ 0.973213  │ 0.802042  │ 0.796163   │
## │ 4   │ 0.298613   │ 0.521171  │ 0.922536  │ 0.0624479 │ 0.157143   │
## │ 5   │ 0.649945   │ 0.286611  │ 0.173691  │ 0.093866  │ 0.00910509 │
## │ 6   │ 0.505125   │ 0.677434  │ 0.724997  │ 0.998958  │ 0.50389    │
## │ 7   │ 0.859137   │ 0.40535   │ 0.0773852 │ 0.806471  │ 0.586517   │
## ⋮
## │ 65  │ 0.80098    │ 0.99825   │ 0.683375  │ 0.800416  │ 0.122661   │
## │ 66  │ 0.647089   │ 0.634504  │ 0.606423  │ 0.799559  │ 0.583944   │
## │ 67  │ 0.895887   │ 0.0981045 │ 0.17749   │ 0.914557  │ 0.0330169  │
## │ 68  │ 0.775965   │ 0.718786  │ 0.229372  │ 0.164901  │ 0.89619    │
## │ 69  │ 0.759445   │ 0.279651  │ 0.184873  │ 0.0181733 │ 0.16676    │
## │ 70  │ 0.242222   │ 0.643847  │ 0.0524266 │ 0.152642  │ 0.886782   │
## │ 71  │ 0.566356   │ 0.0976754 │ 0.856145  │ 0.988628  │ 0.888342   │
## │ 72  │ 0.301572   │ 0.746761  │ 0.224298  │ 0.678956  │ 0.361499   │</code></pre>
<p>In Julia, instead of the syntax <em>condition1 &amp; condition2</em>, which is more common in
other programming languages, we use <strong>&amp;(condition1, condition2)</strong> or
<strong>|(condition1, condition2)</strong> operators to perform multiple conditional
filtering.</p>
<p>Now, let’s say you have a DataFrame and you want to append rows to it. There are
a couple of ways of doing data:</p>
<pre class="julia"><code>## Creating a DataFrame with 3 rows and 5 columns:
x = DataFrame(rand(3, 5));
## Using [dataset1; dataset2]
[ x ; DataFrame(rand(1, 5)) ]</code></pre>
<pre><code>## 4×5 DataFrame
## │ Row │ x1        │ x2       │ x3       │ x4       │ x5         │
## │     │ Float64   │ Float64  │ Float64  │ Float64  │ Float64    │
## ├─────┼───────────┼──────────┼──────────┼──────────┼────────────┤
## │ 1   │ 0.519689  │ 0.553442 │ 0.73233  │ 0.484292 │ 0.128245   │
## │ 2   │ 0.0253178 │ 0.2336   │ 0.89428  │ 0.416471 │ 0.738549   │
## │ 3   │ 0.111505  │ 0.576162 │ 0.590862 │ 0.418522 │ 0.0400396  │
## │ 4   │ 0.238538  │ 0.183391 │ 0.146758 │ 0.584878 │ 0.00700095 │</code></pre>
<p>We could get the same result using the <code>vcat()</code> function. The syntax would be:</p>
<pre><code>vcat(x[1:2, :] , x[3, :])</code></pre>
<p>Another way to do that is using the function <code>append!()</code>. This function will append
a new row to the last row in a given DataFrame. Note that the column names must
match exactly.</p>
<pre class="julia"><code>append!(x, DataFrame(rand(1, 5)))</code></pre>
<pre><code>## 4×5 DataFrame
## │ Row │ x1        │ x2        │ x3       │ x4       │ x5        │
## │     │ Float64   │ Float64   │ Float64  │ Float64  │ Float64   │
## ├─────┼───────────┼───────────┼──────────┼──────────┼───────────┤
## │ 1   │ 0.519689  │ 0.553442  │ 0.73233  │ 0.484292 │ 0.128245  │
## │ 2   │ 0.0253178 │ 0.2336    │ 0.89428  │ 0.416471 │ 0.738549  │
## │ 3   │ 0.111505  │ 0.576162  │ 0.590862 │ 0.418522 │ 0.0400396 │
## │ 4   │ 0.889326  │ 0.0381806 │ 0.42989  │ 0.284753 │ 0.873131  │</code></pre>
<p>Also, we can make use of <code>push!()</code> function to perform the same operation. The
difference is that instead of providing two DataFrames, we can give an array or
dictionary:</p>
<pre class="julia"><code>push!(x, rand(ncol(x)))</code></pre>
<pre><code>## 5×5 DataFrame
## │ Row │ x1        │ x2        │ x3       │ x4        │ x5        │
## │     │ Float64   │ Float64   │ Float64  │ Float64   │ Float64   │
## ├─────┼───────────┼───────────┼──────────┼───────────┼───────────┤
## │ 1   │ 0.519689  │ 0.553442  │ 0.73233  │ 0.484292  │ 0.128245  │
## │ 2   │ 0.0253178 │ 0.2336    │ 0.89428  │ 0.416471  │ 0.738549  │
## │ 3   │ 0.111505  │ 0.576162  │ 0.590862 │ 0.418522  │ 0.0400396 │
## │ 4   │ 0.889326  │ 0.0381806 │ 0.42989  │ 0.284753  │ 0.873131  │
## │ 5   │ 0.980604  │ 0.24727   │ 0.554815 │ 0.0792743 │ 0.263139  │</code></pre>
<pre class="julia"><code>push!(x, Dict(:x1 =&gt; rand(),
              :x2 =&gt; rand(),
              :x3 =&gt; rand(),
              :x4 =&gt; rand(),
              :x5 =&gt; rand()))</code></pre>
<pre><code>## 6×5 DataFrame
## │ Row │ x1        │ x2        │ x3       │ x4        │ x5        │
## │     │ Float64   │ Float64   │ Float64  │ Float64   │ Float64   │
## ├─────┼───────────┼───────────┼──────────┼───────────┼───────────┤
## │ 1   │ 0.519689  │ 0.553442  │ 0.73233  │ 0.484292  │ 0.128245  │
## │ 2   │ 0.0253178 │ 0.2336    │ 0.89428  │ 0.416471  │ 0.738549  │
## │ 3   │ 0.111505  │ 0.576162  │ 0.590862 │ 0.418522  │ 0.0400396 │
## │ 4   │ 0.889326  │ 0.0381806 │ 0.42989  │ 0.284753  │ 0.873131  │
## │ 5   │ 0.980604  │ 0.24727   │ 0.554815 │ 0.0792743 │ 0.263139  │
## │ 6   │ 0.795713  │ 0.694827  │ 0.453864 │ 0.501087  │ 0.413775  │</code></pre>
<p>So, there are at least 4 methods to add rows to the a DataFrame. Which one to use?
Let’s see how fast it is each function:</p>
<pre class="julia"><code>using BenchmarkTools
@btime [x ; DataFrame(rand(1, 5))];
@btime vcat(x, DataFrame(rand(1, 5)));
@btime append!(x, DataFrame(rand(1, 5)));
@btime push!(x, rand(1, 5));</code></pre>
</div>
<div id="manipulating-columns" class="section level2">
<h2>Manipulating Columns:</h2>
<p>One of the first things we would want to do when working with a dataset is selecting
some columns. In Julia, the syntax of selecting columns in DataFrames is similar to the one
used in Matlab/Octave. For instance, we can make use of the <strong>“:”</strong> symbol to represent
that we want all columns (or all rows):</p>
<pre class="julia"><code>## Taking all rows of the first 2 columns:
foo[:, 1:2]</code></pre>
<pre><code>## 100×2 DataFrame
## │ Row │ x1         │ x2        │
## │     │ Float64    │ Float64   │
## ├─────┼────────────┼───────────┤
## │ 1   │ 0.508564   │ 0.79816   │
## │ 2   │ 0.00486372 │ 0.885084  │
## │ 3   │ 0.759279   │ 0.260589  │
## │ 4   │ 0.019347   │ 0.420296  │
## │ 5   │ 0.298613   │ 0.521171  │
## │ 6   │ 0.434307   │ 0.243373  │
## │ 7   │ 0.649945   │ 0.286611  │
## ⋮
## │ 93  │ 0.647089   │ 0.634504  │
## │ 94  │ 0.895887   │ 0.0981045 │
## │ 95  │ 0.775965   │ 0.718786  │
## │ 96  │ 0.759445   │ 0.279651  │
## │ 97  │ 0.484503   │ 0.31399   │
## │ 98  │ 0.242222   │ 0.643847  │
## │ 99  │ 0.566356   │ 0.0976754 │
## │ 100 │ 0.301572   │ 0.746761  │</code></pre>
<pre class="julia"><code>## Taking the first 10 rows of all columns:
foo[1:10, :]</code></pre>
<pre><code>## 10×10 DataFrame. Omitted printing of 4 columns
## │ Row │ x1         │ x2       │ x3        │ x4        │ x5         │ x6        │
## │     │ Float64    │ Float64  │ Float64   │ Float64   │ Float64    │ Float64   │
## ├─────┼────────────┼──────────┼───────────┼───────────┼────────────┼───────────┤
## │ 1   │ 0.508564   │ 0.79816  │ 0.724948  │ 0.427013  │ 0.164095   │ 0.198353  │
## │ 2   │ 0.00486372 │ 0.885084 │ 0.33327   │ 0.647139  │ 0.66389    │ 0.681442  │
## │ 3   │ 0.759279   │ 0.260589 │ 0.973213  │ 0.802042  │ 0.796163   │ 0.0726998 │
## │ 4   │ 0.019347   │ 0.420296 │ 0.654524  │ 0.782539  │ 0.9021     │ 0.65856   │
## │ 5   │ 0.298613   │ 0.521171 │ 0.922536  │ 0.0624479 │ 0.157143   │ 0.99837   │
## │ 6   │ 0.434307   │ 0.243373 │ 0.949971  │ 0.841466  │ 0.316669   │ 0.480473  │
## │ 7   │ 0.649945   │ 0.286611 │ 0.173691  │ 0.093866  │ 0.00910509 │ 0.307678  │
## │ 8   │ 0.505125   │ 0.677434 │ 0.724997  │ 0.998958  │ 0.50389    │ 0.82675   │
## │ 9   │ 0.859137   │ 0.40535  │ 0.0773852 │ 0.806471  │ 0.586517   │ 0.612467  │
## │ 10  │ 0.283877   │ 0.647584 │ 0.79919   │ 0.617992  │ 0.0677399  │ 0.0690236 │</code></pre>
<p>Also, we can select a column by using its name as a symbol or using the “.” operator:</p>
<pre class="julia"><code>## take the column x1 using &quot;.&quot; operator:
foo.x1</code></pre>
<pre><code>## 100-element Array{Float64,1}:
##  0.5085638548360536   
##  0.0048637230983432644
##  0.7592786193335672   
##  0.01934700737444306  
##  0.298613436482579    
##  0.43430740478451524  
##  0.6499451571279791   
##  0.5051247853965111   
##  0.8591371196780011   
##  0.28387689673484795  
##  ⋮                    
##  0.8009795173154461   
##  0.647088661909748    
##  0.8958871137719533   
##  0.7759647110616381   
##  0.7594451737579386   
##  0.4845034743996792   
##  0.24222185914541305  
##  0.5663556499499522   
##  0.30157185781171525</code></pre>
<pre class="julia"><code>## Take the column using &quot;x1&quot; as a symbol:
foo[:x1]</code></pre>
<pre><code>## 100-element Array{Float64,1}:
##  0.5085638548360536   
##  0.0048637230983432644
##  0.7592786193335672   
##  0.01934700737444306  
##  0.298613436482579    
##  0.43430740478451524  
##  0.6499451571279791   
##  0.5051247853965111   
##  0.8591371196780011   
##  0.28387689673484795  
##  ⋮                    
##  0.8009795173154461   
##  0.647088661909748    
##  0.8958871137719533   
##  0.7759647110616381   
##  0.7594451737579386   
##  0.4845034743996792   
##  0.24222185914541305  
##  0.5663556499499522   
##  0.30157185781171525</code></pre>
<p>As we can see, the return will be an Array. To select one or more column and return
them as a DataFrame type, we use the double brackets syntax:</p>
<pre class="julia"><code>## take column x1 as DataFrame
foo[[:x1]] |&gt; head</code></pre>
<pre><code>## 6×1 DataFrame
## │ Row │ x1         │
## │     │ Float64    │
## ├─────┼────────────┤
## │ 1   │ 0.508564   │
## │ 2   │ 0.00486372 │
## │ 3   │ 0.759279   │
## │ 4   │ 0.019347   │
## │ 5   │ 0.298613   │
## │ 6   │ 0.434307   │</code></pre>
<pre class="julia"><code>## Take column x1 an x2:
foo[[:x1, :x2]] |&gt; head</code></pre>
<pre><code>## 6×2 DataFrame
## │ Row │ x1         │ x2       │
## │     │ Float64    │ Float64  │
## ├─────┼────────────┼──────────┤
## │ 1   │ 0.508564   │ 0.79816  │
## │ 2   │ 0.00486372 │ 0.885084 │
## │ 3   │ 0.759279   │ 0.260589 │
## │ 4   │ 0.019347   │ 0.420296 │
## │ 5   │ 0.298613   │ 0.521171 │
## │ 6   │ 0.434307   │ 0.243373 │</code></pre>
<p>Notice the use of the <strong>“|&gt;”</strong> operator. This is the pipe symbol. If you are
familiar with R programming language, It works similarly to the <strong>“%&gt;%”</strong> operator
from <em>magrittr</em> package, but with some limitations. For example, we can not pipe
to a specific argument in a subsequent function.</p>
<p>Another trivial task we can perform with column is to add or alter columns in a
DataFrame. For example, let’s create a new column which will be a sequence between
1 and until 100 by 0.5:</p>
<pre class="julia"><code>## To create a sequence, use the function range():
foo[:new_column] = range(1, step = 0.5, length = nrow(foo));
foo[:, :new_column]</code></pre>
<pre><code>## 100-element Array{Float64,1}:
##   1.0
##   1.5
##   2.0
##   2.5
##   3.0
##   3.5
##   4.0
##   4.5
##   5.0
##   5.5
##   ⋮  
##  46.5
##  47.0
##  47.5
##  48.0
##  48.5
##  49.0
##  49.5
##  50.0
##  50.5</code></pre>
<p>We can also add column using the <code>insert()</code> function. The syntax allow us to
specify in which position we want to add the column in the DataFrame:</p>
<pre class="julia"><code>## syntax: insert!(dataset, position, array, column_name)
insert!(foo, 2, range(1, step = 0.5, length = nrow(foo)), :new_colum2);
foo |&gt; head</code></pre>
<pre><code>## 6×12 DataFrame. Omitted printing of 6 columns
## │ Row │ x1         │ new_colum2 │ x2       │ x3       │ x4        │ x5       │
## │     │ Float64    │ Float64    │ Float64  │ Float64  │ Float64   │ Float64  │
## ├─────┼────────────┼────────────┼──────────┼──────────┼───────────┼──────────┤
## │ 1   │ 0.508564   │ 1.0        │ 0.79816  │ 0.724948 │ 0.427013  │ 0.164095 │
## │ 2   │ 0.00486372 │ 1.5        │ 0.885084 │ 0.33327  │ 0.647139  │ 0.66389  │
## │ 3   │ 0.759279   │ 2.0        │ 0.260589 │ 0.973213 │ 0.802042  │ 0.796163 │
## │ 4   │ 0.019347   │ 2.5        │ 0.420296 │ 0.654524 │ 0.782539  │ 0.9021   │
## │ 5   │ 0.298613   │ 3.0        │ 0.521171 │ 0.922536 │ 0.0624479 │ 0.157143 │
## │ 6   │ 0.434307   │ 3.5        │ 0.243373 │ 0.949971 │ 0.841466  │ 0.316669 │</code></pre>
<p>Note the use of the <strong>“!”</strong> in <em>insert!()</em> function. This means that the function
is altering the object in memory rather than in a “virtual copy” that later needs
to be assigned to a new variable. This is a behavior that can be used in other function
as well.</p>
<p>Ok… But what if you want to do the opposite? that is, to remove a column?
Well… it is just as easy as to add it. Just use the <code>delete!()</code> function:</p>
<pre class="julia"><code>delete!(foo, [:new_column, :new_colum2])</code></pre>
<pre><code>## 100×10 DataFrame. Omitted printing of 5 columns
## │ Row │ x1         │ x2        │ x3        │ x4        │ x5         │
## │     │ Float64    │ Float64   │ Float64   │ Float64   │ Float64    │
## ├─────┼────────────┼───────────┼───────────┼───────────┼────────────┤
## │ 1   │ 0.508564   │ 0.79816   │ 0.724948  │ 0.427013  │ 0.164095   │
## │ 2   │ 0.00486372 │ 0.885084  │ 0.33327   │ 0.647139  │ 0.66389    │
## │ 3   │ 0.759279   │ 0.260589  │ 0.973213  │ 0.802042  │ 0.796163   │
## │ 4   │ 0.019347   │ 0.420296  │ 0.654524  │ 0.782539  │ 0.9021     │
## │ 5   │ 0.298613   │ 0.521171  │ 0.922536  │ 0.0624479 │ 0.157143   │
## │ 6   │ 0.434307   │ 0.243373  │ 0.949971  │ 0.841466  │ 0.316669   │
## │ 7   │ 0.649945   │ 0.286611  │ 0.173691  │ 0.093866  │ 0.00910509 │
## ⋮
## │ 93  │ 0.647089   │ 0.634504  │ 0.606423  │ 0.799559  │ 0.583944   │
## │ 94  │ 0.895887   │ 0.0981045 │ 0.17749   │ 0.914557  │ 0.0330169  │
## │ 95  │ 0.775965   │ 0.718786  │ 0.229372  │ 0.164901  │ 0.89619    │
## │ 96  │ 0.759445   │ 0.279651  │ 0.184873  │ 0.0181733 │ 0.16676    │
## │ 97  │ 0.484503   │ 0.31399   │ 0.0153769 │ 0.723479  │ 0.736016   │
## │ 98  │ 0.242222   │ 0.643847  │ 0.0524266 │ 0.152642  │ 0.886782   │
## │ 99  │ 0.566356   │ 0.0976754 │ 0.856145  │ 0.988628  │ 0.888342   │
## │ 100 │ 0.301572   │ 0.746761  │ 0.224298  │ 0.678956  │ 0.361499   │</code></pre>
<p>Now suppose that you do not want to delete a colum, but just change the column
name. For this task, I am afraid there is a very difficult function to remember
the name: <code>rename()</code> function. The syntax is as follows:</p>
<pre class="julia"><code>## rename(dataFrame, :old_name =&gt; :new_name)
rename(foo, :x1 =&gt; :A1, :x2 =&gt; :A2)</code></pre>
<pre><code>## 100×10 DataFrame. Omitted printing of 5 columns
## │ Row │ A1         │ A2        │ x3        │ x4        │ x5         │
## │     │ Float64    │ Float64   │ Float64   │ Float64   │ Float64    │
## ├─────┼────────────┼───────────┼───────────┼───────────┼────────────┤
## │ 1   │ 0.508564   │ 0.79816   │ 0.724948  │ 0.427013  │ 0.164095   │
## │ 2   │ 0.00486372 │ 0.885084  │ 0.33327   │ 0.647139  │ 0.66389    │
## │ 3   │ 0.759279   │ 0.260589  │ 0.973213  │ 0.802042  │ 0.796163   │
## │ 4   │ 0.019347   │ 0.420296  │ 0.654524  │ 0.782539  │ 0.9021     │
## │ 5   │ 0.298613   │ 0.521171  │ 0.922536  │ 0.0624479 │ 0.157143   │
## │ 6   │ 0.434307   │ 0.243373  │ 0.949971  │ 0.841466  │ 0.316669   │
## │ 7   │ 0.649945   │ 0.286611  │ 0.173691  │ 0.093866  │ 0.00910509 │
## ⋮
## │ 93  │ 0.647089   │ 0.634504  │ 0.606423  │ 0.799559  │ 0.583944   │
## │ 94  │ 0.895887   │ 0.0981045 │ 0.17749   │ 0.914557  │ 0.0330169  │
## │ 95  │ 0.775965   │ 0.718786  │ 0.229372  │ 0.164901  │ 0.89619    │
## │ 96  │ 0.759445   │ 0.279651  │ 0.184873  │ 0.0181733 │ 0.16676    │
## │ 97  │ 0.484503   │ 0.31399   │ 0.0153769 │ 0.723479  │ 0.736016   │
## │ 98  │ 0.242222   │ 0.643847  │ 0.0524266 │ 0.152642  │ 0.886782   │
## │ 99  │ 0.566356   │ 0.0976754 │ 0.856145  │ 0.988628  │ 0.888342   │
## │ 100 │ 0.301572   │ 0.746761  │ 0.224298  │ 0.678956  │ 0.361499   │</code></pre>
<p>We could also add the <strong>“!”</strong> to the <code>rename()</code> function to alter the DataFrame
in memory.</p>
</div>
<div id="lets-talk-about-missing-values" class="section level2">
<h2>Let’s talk about missing values:</h2>
<p>Missing values are represented in Julia with <strong>missing</strong> value. When an array
contains missing values, it automatically creates an appropriate union type:</p>
<pre class="julia"><code>x = [1.0, 2.0, missing]</code></pre>
<pre><code>## 3-element Array{Union{Missing, Float64},1}:
##  1.0     
##  2.0     
##   missing</code></pre>
<pre class="julia"><code>typeof(x)</code></pre>
<pre><code>## Array{Union{Missing, Float64},1}</code></pre>
<pre class="julia"><code>typeof.(x)</code></pre>
<pre><code>## 3-element Array{DataType,1}:
##  Float64
##  Float64
##  Missing</code></pre>
<p>To check if a particular element in an array is missing, we use the <code>ismissing()</code>
function:</p>
<pre class="julia"><code>ismissing.([1.0, 2.0, missing])</code></pre>
<pre><code>## 3-element BitArray{1}:
##  false
##  false
##   true</code></pre>
<p>It is important to notice that <em>missing</em> comparison produces <em>missing</em> as a result:</p>
<pre class="julia"><code>missing == missing</code></pre>
<p><strong>isequal</strong> and <strong>===</strong> an be used to produce the results of type <em>Bool</em>:</p>
<pre class="julia"><code>isequal(missing, missing)</code></pre>
<pre><code>## true</code></pre>
<pre class="julia"><code>missing == missing</code></pre>
<p>Other functions are available to work with missing values. For instance, suppose
we want an array with only non-missing values, we use the <code>skipmissing()</code>:</p>
<pre class="julia"><code>x |&gt; skipmissing |&gt; collect</code></pre>
<pre><code>## 2-element Array{Float64,1}:
##  1.0
##  2.0</code></pre>
<p>Here, we use the <code>collect()</code> function as the <code>skipmissing()</code> returns an iterator.</p>
<p>To replace the missing values with some other value we can use the
<code>Missings.replace()</code> function. For example, suppose we want to change the missing
values by <em>NaN</em>:</p>
<pre class="julia"><code>Missings.replace(x, NaN) |&gt; collect</code></pre>
<pre><code>## 3-element Array{Float64,1}:
##    1.0
##    2.0
##  NaN</code></pre>
<p>We also can use use other ways to perform the same operation:</p>
<pre class="julia"><code>## Using coalesce() function:
coalesce.(x, NaN)</code></pre>
<pre><code>## 3-element Array{Float64,1}:
##    1.0
##    2.0
##  NaN</code></pre>
<pre class="julia"><code>## Using recode() function:
recode(x, missing =&gt; NaN)</code></pre>
<pre><code>## 3-element Array{Float64,1}:
##    1.0
##    2.0
##  NaN</code></pre>
<p>Until now, we have only talked about missing values in arrays. But what about missing
values in DataFrames? To start, let’s create a DataFrame with some missing values:</p>
<pre class="julia"><code>x = DataFrame(A = [1, missing, 3, 4], B = [&quot;A&quot;, &quot;B&quot;, missing, &quot;C&quot;])</code></pre>
<pre><code>## 4×2 DataFrame
## │ Row │ A       │ B       │
## │     │ Int64⍰  │ String⍰ │
## ├─────┼─────────┼─────────┤
## │ 1   │ 1       │ A       │
## │ 2   │ missing │ B       │
## │ 3   │ 3       │ missing │
## │ 4   │ 4       │ C       │</code></pre>
<p>For some analysis, we would want only the rows with non-missing values. One way
to achieve this we can make use of the <code>completecases()</code> function:</p>
<pre class="julia"><code>x[completecases(x), :]</code></pre>
<pre><code>## 2×2 DataFrame
## │ Row │ A      │ B       │
## │     │ Int64⍰ │ String⍰ │
## ├─────┼────────┼─────────┤
## │ 1   │ 1      │ A       │
## │ 2   │ 4      │ C       │</code></pre>
<p>The <code>completecases()</code> function returns an boolean array with value <em>true</em> for
rows that have non-missing values and <em>false</em> otherwise. For those who are familiar
with R, this is the same behavior as the <code>complete.cases()</code> function from stats package.</p>
<p>Another option to return the rows with non-missing values of a DataFrame in Julia
is to use the <code>dropmissing()</code> function:</p>
<pre class="julia"><code>dropmissing(x)</code></pre>
<pre><code>## 2×2 DataFrame
## │ Row │ A      │ B       │
## │     │ Int64⍰ │ String⍰ │
## ├─────┼────────┼─────────┤
## │ 1   │ 1      │ A       │
## │ 2   │ 4      │ C       │</code></pre>
<p>and again, for R users is the same behaviro as <em>na.omit()</em> function.</p>
</div>
<div id="merging-dataframes" class="section level2">
<h2>Merging DataFrames:</h2>
<p>Often, we need to combine two or more DataFrames together based on some common
column(s) among them. For example, suppose we have two DataFrames:</p>
<pre class="julia"><code>df1 = DataFrame(x = 1:3, y = 4:6)</code></pre>
<pre><code>## 3×2 DataFrame
## │ Row │ x     │ y     │
## │     │ Int64 │ Int64 │
## ├─────┼───────┼───────┤
## │ 1   │ 1     │ 4     │
## │ 2   │ 2     │ 5     │
## │ 3   │ 3     │ 6     │</code></pre>
<pre class="julia"><code>df2 = DataFrame(x = 1:3, z = &#39;d&#39;:&#39;f&#39;, new = 11:13)</code></pre>
<pre><code>## 3×3 DataFrame
## │ Row │ x     │ z    │ new   │
## │     │ Int64 │ Char │ Int64 │
## ├─────┼───────┼──────┼───────┤
## │ 1   │ 1     │ &#39;d&#39;  │ 11    │
## │ 2   │ 2     │ &#39;e&#39;  │ 12    │
## │ 3   │ 3     │ &#39;f&#39;  │ 13    │</code></pre>
<p>which have the column <em>x</em> in common. To merge these two tables, we use the
<code>join()</code> function:</p>
<pre class="julia"><code>join(df1, df2, on = :x)</code></pre>
<pre><code>## 3×4 DataFrame
## │ Row │ x     │ y     │ z    │ new   │
## │     │ Int64 │ Int64 │ Char │ Int64 │
## ├─────┼───────┼───────┼──────┼───────┤
## │ 1   │ 1     │ 4     │ &#39;d&#39;  │ 11    │
## │ 2   │ 2     │ 5     │ &#39;e&#39;  │ 12    │
## │ 3   │ 3     │ 6     │ &#39;f&#39;  │ 13    │</code></pre>
<p>That it!! We merge our DataFrames altogether. But that’s the default behavior of
the function. There is more to explore. Essentially, <code>join()</code> takes 4 arguments:</p>
<ul>
<li>DataFrame 1</li>
<li>DataFrame 2</li>
<li>on = the column(s) to be the key in merging;</li>
<li>kind = type of the merge (left, right, inner, outer, …)</li>
</ul>
<p>The <em>kind</em> argument specifies the type of join we are interested in performing.
The definition of each one is as follows:</p>
<ul>
<li><p><em>Inner</em>: The output contains rows for values of the key that exist
in <strong>BOTH</strong> the first (left) and second (right) arguments to
join;</p></li>
<li><p><em>Left</em>: The output contains rows for values of the key that exist in
the first (left) argument to join, whether or not that value
exists in the second (right) argument;</p></li>
<li><p><em>Right</em>: The output contains rows for values of the key that exist in
the second (right) argument to join, whether or not that
value exists in the first (left) argument;</p></li>
<li><p><em>Outer</em>: The output contains rows for values of the key that exist in
the first (left) <strong>OR</strong> second (right) argument to join;</p></li>
</ul>
<p>and here are the strange ones:</p>
<ul>
<li><p><em>Semi</em>: Like an inner join, but output is restricted to columns from
the first (left) argument to join;</p></li>
<li><p><em>Anti</em>: The output contains rows for values of the key that exist in
the first (left) but <strong>NOT</strong> in the second (right) argument to
join. As with semi joins, output is restricted to columns
from the first (left) argument.</p></li>
</ul>
<p>If you are familiar with <em>SQL</em> or with the join functions from <em>dplyr</em> package in R,
it is the same concept.</p>
<p>To illustrate how the different kind of joins work, let’s create more DataFrames
to demonstrate each type of join:</p>
<pre class="julia"><code>Names = DataFrame(ID = [20, 40], Name = [&quot;John Doe&quot;, &quot;Jane Doe&quot;])</code></pre>
<pre><code>## 2×2 DataFrame
## │ Row │ ID    │ Name     │
## │     │ Int64 │ String   │
## ├─────┼───────┼──────────┤
## │ 1   │ 20    │ John Doe │
## │ 2   │ 40    │ Jane Doe │</code></pre>
<pre class="julia"><code>jobs = DataFrame(ID = [20, 60], Job = [&quot;Lawyer&quot;, &quot;Astronaut&quot;])</code></pre>
<pre><code>## 2×2 DataFrame
## │ Row │ ID    │ Job       │
## │     │ Int64 │ String    │
## ├─────┼───────┼───────────┤
## │ 1   │ 20    │ Lawyer    │
## │ 2   │ 60    │ Astronaut │</code></pre>
<p>In the Names and jobs DataFrame, we have the ID column as the key to perform the
join. But notice that the ID values are not equal between the DataFrames. Now
let’s perform the joins:</p>
<pre class="julia"><code>join(Names, jobs, on = :ID, kind = :inner)</code></pre>
<pre><code>## 1×3 DataFrame
## │ Row │ ID    │ Name     │ Job    │
## │     │ Int64 │ String   │ String │
## ├─────┼───────┼──────────┼────────┤
## │ 1   │ 20    │ John Doe │ Lawyer │</code></pre>
<pre class="julia"><code>join(Names, jobs, on = :ID, kind = :left)</code></pre>
<pre><code>## 2×3 DataFrame
## │ Row │ ID    │ Name     │ Job     │
## │     │ Int64 │ String   │ String⍰ │
## ├─────┼───────┼──────────┼─────────┤
## │ 1   │ 20    │ John Doe │ Lawyer  │
## │ 2   │ 40    │ Jane Doe │ missing │</code></pre>
<pre class="julia"><code>join(Names, jobs, on = :ID, kind = :right)</code></pre>
<pre><code>## 2×3 DataFrame
## │ Row │ ID    │ Name     │ Job       │
## │     │ Int64 │ String⍰  │ String    │
## ├─────┼───────┼──────────┼───────────┤
## │ 1   │ 20    │ John Doe │ Lawyer    │
## │ 2   │ 60    │ missing  │ Astronaut │</code></pre>
<pre class="julia"><code>join(Names, jobs, on = :ID, kind = :outer)</code></pre>
<pre><code>## 3×3 DataFrame
## │ Row │ ID    │ Name     │ Job       │
## │     │ Int64 │ String⍰  │ String⍰   │
## ├─────┼───────┼──────────┼───────────┤
## │ 1   │ 20    │ John Doe │ Lawyer    │
## │ 2   │ 40    │ Jane Doe │ missing   │
## │ 3   │ 60    │ missing  │ Astronaut │</code></pre>
<p><em>Semi</em> and <em>anti</em> join have a more uncommon behavior. Semi join returns the rows
from the left which <strong>DOES MATCHES</strong> with the ID from the right:</p>
<pre class="julia"><code>join(Names, jobs, on = :ID, kind = :semi)</code></pre>
<pre><code>## 1×2 DataFrame
## │ Row │ ID    │ Name     │
## │     │ Int64 │ String   │
## ├─────┼───────┼──────────┤
## │ 1   │ 20    │ John Doe │</code></pre>
<p>Anti join returns the rows from the left which <strong>DOES NOT MATCH</strong> with
the ID from the right</p>
<pre class="julia"><code>join(Names, jobs, on = :ID, kind = :anti)</code></pre>
<pre><code>## 1×2 DataFrame
## │ Row │ ID    │ Name     │
## │     │ Int64 │ String   │
## ├─────┼───────┼──────────┤
## │ 1   │ 40    │ Jane Doe │</code></pre>
</div>
<div id="split-apply-combine" class="section level2">
<h2>Split-Apply-Combine:</h2>
<p>Some common tasks involve split the data into groups, applying some function
to each of these groups and gather the results to analyze later on. This is the
split-apply-combine strategy described in the paper “<a href="https://www.jstatsoft.org/article/view/v040i01">The Split-Apply-Combine Strategy for Data analysis</a>” written by Hadley Wickham, creator
of many R packages, including <em>ggplot2</em> and <em>dplyr</em>.</p>
<p>The DataFrames package in Julia supports the Split-Apply-Combine strategy
through the <code>by()</code> function, which takes three arguments:</p>
<ul>
<li>DataFrame;</li>
<li>one or more column names to split on;</li>
<li>a function or expression to apply to each subset;</li>
</ul>
<p>To illustrate its usage, let’s make use of the <em>RDatasets</em> package, which gives
access to some preloaded well known datasets from R packages.</p>
<pre class="julia"><code>using RDatasets
foo = dataset(&quot;datasets&quot;, &quot;iris&quot;);
foo |&gt; head</code></pre>
<pre><code>## 6×5 DataFrame
## │ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species      │
## │     │ Float64     │ Float64    │ Float64     │ Float64    │ Categorical… │
## ├─────┼─────────────┼────────────┼─────────────┼────────────┼──────────────┤
## │ 1   │ 5.1         │ 3.5        │ 1.4         │ 0.2        │ setosa       │
## │ 2   │ 4.9         │ 3.0        │ 1.4         │ 0.2        │ setosa       │
## │ 3   │ 4.7         │ 3.2        │ 1.3         │ 0.2        │ setosa       │
## │ 4   │ 4.6         │ 3.1        │ 1.5         │ 0.2        │ setosa       │
## │ 5   │ 5.0         │ 3.6        │ 1.4         │ 0.2        │ setosa       │
## │ 6   │ 5.4         │ 3.9        │ 1.7         │ 0.4        │ setosa       │</code></pre>
<p>A trivial task is to do is to find how many of each “Species” there are in the
dataset. One way to do this is to apply the split-apply-combine strategy: <strong>split</strong>
the data into the <em>species</em> column, <strong>apply</strong> the <em>nrow()</em> function to this
splitted dataset, and <strong>combine</strong> the results:</p>
<pre class="julia"><code>## Syntax: by(dataset, :name_column_to_split, name_function)
by(foo, :Species, nrow)</code></pre>
<pre><code>## 3×2 DataFrame
## │ Row │ Species      │ x1    │
## │     │ Categorical… │ Int64 │
## ├─────┼──────────────┼───────┤
## │ 1   │ setosa       │ 50    │
## │ 2   │ versicolor   │ 50    │
## │ 3   │ virginica    │ 50    │</code></pre>
<p>We can also use anonymous function:</p>
<pre class="julia"><code>by(foo, :Species, x -&gt; DataFrame(N = nrow(x)))</code></pre>
<pre><code>## 3×2 DataFrame
## │ Row │ Species      │ N     │
## │     │ Categorical… │ Int64 │
## ├─────┼──────────────┼───────┤
## │ 1   │ setosa       │ 50    │
## │ 2   │ versicolor   │ 50    │
## │ 3   │ virginica    │ 50    │</code></pre>
<p>One of the advantages of using anonymous function inside the <code>by()</code> function is
that we can format the resulted output and apply as many function as we want:</p>
<pre class="julia"><code>## Applying the count, mean and standard deviation function:
by(foo, :Species, x -&gt; DataFrame(N = nrow(x),
                                 avg_PetalLength = mean(x[:PetalLength]),
                                 std_PetalWidth = std(x[:PetalWidth])))</code></pre>
<pre><code>## 3×4 DataFrame
## │ Row │ Species      │ N     │ avg_PetalLength │ std_PetalWidth │
## │     │ Categorical… │ Int64 │ Float64         │ Float64        │
## ├─────┼──────────────┼───────┼─────────────────┼────────────────┤
## │ 1   │ setosa       │ 50    │ 1.462           │ 0.105386       │
## │ 2   │ versicolor   │ 50    │ 4.26            │ 0.197753       │
## │ 3   │ virginica    │ 50    │ 5.552           │ 0.27465        │</code></pre>
<p>Another way to use the Split-Apply-Combine strategy is implementing the
<code>aggregate()</code> function, which also takes three arguments:</p>
<ul>
<li>DataFrame;</li>
<li>one or more column names to split on;</li>
<li>one or more function to be applied <strong>ON THE COLUMNS NOT USED TO SPLIT</strong>.</li>
</ul>
<p>The difference between <code>by()</code> and <code>aggregate()</code> function is that in the
latter, the function(s) will be applied to each column not used in
the split part.</p>
<p>For instance, let’s say you want the average of each colum for each <em>Species</em>.
Instead of using <code>by()</code> with an anonymous function and writing the name of all columns
we can do:</p>
<pre class="julia"><code>aggregate(foo, :Species, [mean])</code></pre>
<pre><code>## 3×5 DataFrame. Omitted printing of 1 columns
## │ Row │ Species      │ SepalLength_mean │ SepalWidth_mean │ PetalLength_mean │
## │     │ Categorical… │ Float64          │ Float64         │ Float64          │
## ├─────┼──────────────┼──────────────────┼─────────────────┼──────────────────┤
## │ 1   │ setosa       │ 5.006            │ 3.428           │ 1.462            │
## │ 2   │ versicolor   │ 5.936            │ 2.77            │ 4.26             │
## │ 3   │ virginica    │ 6.588            │ 2.974           │ 5.552            │</code></pre>
<p>Note that Julia only display output that fits the screen. Pay
attention to the message “<em>Omitted printing of 1 columns</em>”. To
overcome this, use the <code>show()</code> as advised before.</p>
</div>
</div>
<div id="reading-and-writting-csv-files" class="section level1">
<h1>Reading and Writting CSV files:</h1>
<p>Last but not least, let’s see how to read and write CSV files into/from Julia.
Although this is not exactly handled by the <em>DataFrames</em> package, the task of
reading/writing CSV files are so natural when working with DataFrame that I will
show you the basics.</p>
<p>To read/write CSV files, we use the <strong>CSV</strong> package. To demonstrate its usage,
let’s work with the iris dataset and write a CSV file to a local computer. Then,
we read it back.</p>
<p>So, first we are going to write the <em>foo</em> object (which contains the <em>iris</em> dataset)
to a CSV file. To do this we will use the <code>CSV.write()</code> function. Some useful
arguments in CSV.write are:</p>
<ul>
<li><em>delim</em> : the file’s delimeter. Default ‘,’.</li>
<li><em>header</em> : boolean whether to write the colnames from source;</li>
<li><em>colnames</em> : provide colnames to be written;</li>
<li><em>append</em> : bool to indicate if it to append data;</li>
<li><em>missingstring</em> : string that indicates how missing values will be represented.</li>
</ul>
<pre class="julia"><code>using CSV
CSV.write(&quot;./iris.csv&quot;, foo, missingsstring = &quot;NA&quot;)</code></pre>
<pre><code>## &quot;./iris.csv&quot;</code></pre>
<p>To read a CSV file, we use the <code>CSV.read()</code>. Some useful arguments are:</p>
<ul>
<li><em>delim</em> : a Char or String that indicates how columns are delimited in a file
file’s delimeter. Default ‘,’;</li>
<li><em>decimal</em> : a Char indicating how decimals are separated in
floats. Default ‘.’ ;</li>
<li><em>limit</em> : indicates the total number of rows to read;</li>
<li><em>header</em> : provide manually the names of the columns.</li>
<li><em>types</em> : a Vector or Dict of types to be used for column types.</li>
</ul>
<pre class="julia"><code>iris = CSV.read(&quot;./iris.csv&quot;)</code></pre>
<pre><code>## 150×5 DataFrame
## │ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species   │
## │     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ String⍰   │
## ├─────┼─────────────┼────────────┼─────────────┼────────────┼───────────┤
## │ 1   │ 5.1         │ 3.5        │ 1.4         │ 0.2        │ setosa    │
## │ 2   │ 4.9         │ 3.0        │ 1.4         │ 0.2        │ setosa    │
## │ 3   │ 4.7         │ 3.2        │ 1.3         │ 0.2        │ setosa    │
## │ 4   │ 4.6         │ 3.1        │ 1.5         │ 0.2        │ setosa    │
## │ 5   │ 5.0         │ 3.6        │ 1.4         │ 0.2        │ setosa    │
## │ 6   │ 5.4         │ 3.9        │ 1.7         │ 0.4        │ setosa    │
## │ 7   │ 4.6         │ 3.4        │ 1.4         │ 0.3        │ setosa    │
## ⋮
## │ 143 │ 5.8         │ 2.7        │ 5.1         │ 1.9        │ virginica │
## │ 144 │ 6.8         │ 3.2        │ 5.9         │ 2.3        │ virginica │
## │ 145 │ 6.7         │ 3.3        │ 5.7         │ 2.5        │ virginica │
## │ 146 │ 6.7         │ 3.0        │ 5.2         │ 2.3        │ virginica │
## │ 147 │ 6.3         │ 2.5        │ 5.0         │ 1.9        │ virginica │
## │ 148 │ 6.5         │ 3.0        │ 5.2         │ 2.0        │ virginica │
## │ 149 │ 6.2         │ 3.4        │ 5.4         │ 2.3        │ virginica │
## │ 150 │ 5.9         │ 3.0        │ 5.1         │ 1.8        │ virginica │</code></pre>
<p>It is important to note that when loading in a DataFrame from a CSV, all columns
allow Missing by default.</p>
<p>This is the basics of reading/writting CSV files in Julia. To get more details
refers to the <a href="http://juliadata.github.io/CSV.jl/latest/#High-level-interface-1">official documentation</a>.</p>
</div>
<div id="conclusion" class="section level1">
<h1>Conclusion:</h1>
<p>This post was a very small introduction to the <strong>DataFrames</strong> packages in Julia.
After reading this post you will be able to read CSV datasets and perform some
tasks with the data at hand.</p>
<p>In the following posts, we will explore more advanced tricks to perform data
wrangling and exploratory data analysis. At each step we are going to build
knowledge to completely use Julia to perform data analysis for any problem that
you might face.</p>
</div>

            </div>
            
            <div class="post-comments">
                
            </div>
            
            <div class="push"></div>
        </div>
        <footer class="footer text-center">
<p>Copyright &copy; 2019 Mr Farias -
<span class="credit">
	Powered by
	<a target="_blank" href="https://gohugo.io">Hugo</a>
	and
	<a target="_blank" href="https://github.com/LordMathis/hugo-theme-nix/">Nix</a> theme.
</span>
</p>
</footer>

    </body>
