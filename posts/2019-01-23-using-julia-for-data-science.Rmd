---
title: Using Julia for Data Science
author: Cleyton Farias
date: '2019-01-23'
slug: using-julia-for-data-science
categories:
  - Julia
tags:
  - Julia
  - Data Science
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
knitr::knit_engines$set(julia = JuliaCall::eng_juliacall)
```

This a quick introduction to the Julia programming language 
and will be presented to you how you can work rightaway with datasets with Julia. 

# Why Julia?

Julia is a high level programming language released in 2012 by a team of MIT 
researchers. Since its beginning, the aim was to solve the so called two-language 
programing problem: easy to use functionalities of interpretable languages 
(Python, R, Matlab) vs high performance of compiled languages (C, C++, Fortran).

Hence, Julia was born. Combining the JIT (Just In Time) compiler and 
Julia's multiple-dispatch system plus the fact that its codebase is written entirely in 
native language, Julia gives birth to the popular phrase in the community:

**"Walks like Python, runs like C."**



# Introduction to DataFrames in Julia

In Julia, tablular data is handled using the **DataFrames** package. Other packages
are commonly used to read/write data into/from Julia such as **CSV**. 

A data frame is created using the *DataFrame()* function:

```{julia}
using DataFrames
foo = DataFrame();
foo 
```

To use the functionalities of the package, let's create some random data. I will
use the *rand()* function to generate random numbers to create an array 100 x 10 
and convert it to a data frame:

```{julia}
foo = DataFrame(rand(100, 10));
foo 
```

To get the dimension of a data frame, we can use the **size()** function. Also, 
**nrow()** and **ncol()** are available to get the number of rows and columns:

```{julia}
size(foo)
nrow(foo)
ncol(foo)
```

To get the column names, we use the **names()** function:

```{julia}
names(foo)
```

To get a summary of the dataset in general, we can use the function **describe()**:

```{julia}
describe(foo)
```

Note that there is a message indicating the omission of two columns. This is the
default behavior of Julia. To avoid this feature, we use the **show()** function 
as follows:

    show(describe(foo), allcols = true)

## Manipulating Rows:

Subset rows in Julia can be a little odd, but once you get used to, it becomes 
more logical. For example, suppose we want the rows where x1 is above the average. 
We could this as follows:


```{julia}
## Loading the Statistics package:
using Statistics

## Creating the conditional:
cond01 = foo[:x1] .>= mean(foo[:x1]);

## Subsetting:
foo[cond01, :] |> head
```

What if we want two conditionals? For example, we want the same condition as before
and/or the rows where x2 is greater than or equal its average? Now things
become trickier. Let's check how we would do this:


```{julia}
## Creating the second conditional:
cond02 = foo[:x2] .>= mean(foo[:x2]);

## Subsetting cond01 AND cond02:
foo[.&(cond01, cond02), :]
## Subsetting cond01 OR cond02:
foo[.|(cond01, cond02), :]
```

In Julia, instead of the syntax *condition1 & condition2*, which is more common in 
other programming languages, we use **&(condition1, condition2)** or 
**|(condition1, condition2)** operators to perform multiple conditional 
filtering. 

Now, let's say you have a DataFrame and you want to append rows to it. There are
a couple of ways of doing data:

```{julia}
## Creating a DataFrame with 3 rows and 5 columns:
x = DataFrame(rand(3, 5));
## Using [dataset1; dataset2]
[ x ; DataFrame(rand(1, 5)) ]
```

We could get the same result using the **vcat()** function. The syntax would be:
    
    vcat(x[1:2, :] , x[3, :])


Another way to do that is using the function **append!()**. This function will append 
a new row to the last row in a given DataFrame. Note that the column names must 
match exactly.

```{julia}
append!(x, DataFrame(rand(1, 5)))
```

Also, we can make use of **push!()** function to perform the same operation. The 
difference is that instead of providing two DataFrames, we can give an array or
dictionary:

```{julia}
push!(x, rand(ncol(x)))
push!(x, Dict(:x1 => rand(),
              :x2 => rand(),
              :x3 => rand(),
              :x4 => rand(),
              :x5 => rand()))
```

So, there are at least 4 methods to add rows to the a DataFrame. Which one to use? 
Let's see how fast it is each function:

```{julia}
using BenchmarkTools
@btime [x ; DataFrame(rand(1, 5))];
@btime vcat(x, DataFrame(rand(1, 5)));
@btime append!(x, DataFrame(rand(1, 5)));
@btime push!(x, rand(1, 5));
```




## Manipulating Columns:


One of the first things we would want to do when working with a dataset is selecting
some columns. In Julia, the syntax of selecting columns in DataFrames is similar to the one
used in Matlab/Octave. For instance, we can make use of the **":"** symbol to represent
that we want all columns (or all rows):

```{julia}
## Taking all rows of the first 2 columns:
foo[:, 1:2]
## Taking the first 10 rows of all columns:
foo[1:10, :]
```

Also, we can select a column by using its name as a symbol or using the "." operator:

```{julia}
## take the column x1 using "." operator:
foo.x1
## Take the column using "x1" as a symbol:
foo[:x1]
```

As we can see, the return will be an Array. To select one or more column and return
them as a DataFrame type, we use the double brackets syntax:

```{julia}
## take column x1 as DataFrame
foo[[:x1]] |> head
## Take column x1 an x2:
foo[[:x1, :x2]] |> head
```

Notice the use of the **"|>"** operator. This is the pipe symbol. If you are 
familiar with R programming language, It works similarly to the *"%>%"* operator 
from *magrittr* package, but with some limitations. For example, we can not pipe
to a specific argument in a subsequent function. 


Another trivial task we can perform with column is to add or alter columns in a
DataFrame. For example, let's create a new column which will be a sequence between
1 and until 100 by 0.5:

```{julia}
## To create a sequence, use the function range():
foo[:new_column] = range(1, step = 0.5, length = nrow(foo));
foo[:, :new_column]
```

We can also add column using the **insert()** function. The syntax allow us to 
specify in which position we want to add the column in the DataFrame:

```{julia}
## syntax: insert!(dataset, position, array, column_name)
insert!(foo, 2, range(1, step = 0.5, length = nrow(foo)), :new_colum2);
foo |> head
```


Note the use of the **"!"** in *insert!()* function. This means that the function
is altering the object in memory rather than in a "virtual copy" that later needs
to be assigned to a new variable. This is a behavior that can be used in other function
as well. 

Ok... But what if you want to do the opposite? that is, to remove a column? 
Well... it is just as easy as to add it. Just use the **delete!()** function:

```{julia}
delete!(foo, [:new_column, :new_colum2])
```

Now suppose that you do not want to delete a colum, but just change the column 
name. For this task, I am afraid there is a very difficult function to remember 
the name: **rename()** function.  The syntax is as follows:

```{julia}
## rename(dataFrame, :old_name => :new_name)
rename(foo, :x1 => :A1, :x2 => :A2)
```

We could also add the **"!"** to the  *rename()* function to alter the DataFrame
in memory.


## Let's talk about missing values:

Missing values are represented in Julia with **missing** value. When an array 
contains missing values, it automatically creates an appropriate union type:

```{julia}
x = [1.0, 2.0, missing]
typeof(x)
typeof.(x)
```

To check if a particular element in an array is missing, we use the **ismissing()** 
function:

```{julia}
ismissing.([1.0, 2.0, missing])
```

It is important to notice that *missing* comparison produces *missing* as a result:

```{julia}
missing == missing
```

**isequal** and **===** an be used to produce the results of type *Bool*:

```{julia}
isequal(missing, missing)
missing == missing
```

Other functions are available to work with missing values. For instance, suppose 
we want an array with only non-missing values, we use the **skipmissing()**:

```{julia}
x |> skipmissing |> collect
```

Here, we use the **collect()** function as the **skipmissing()** returns an iterator.

To replace the missing values with some other value we can use the 
**Missings.replace()** function. For example, suppose we want to change the missing
values by *NaN*:

```{julia}
Missings.replace(x, NaN) |> collect
```

We also can use use other ways to perform the same operation:

```{julia}
## Using coalesce() function:
coalesce.(x, NaN)
## Using recode() function:
recode(x, missing => NaN)
```

Until now, we have only talked about missing values in arrays. But what about missing 
values in DataFrames? To start, let's create a DataFrame with some missing values:

```{julia}
x = DataFrame(A = [1, missing, 3, 4], B = ["A", "B", missing, "C"])
```

For some analysis, we would want only the rows with non-missing values. One way 
to achieve this we can make use of the **completecases()** function:

```{julia}
x[completecases(x), :]
```

The **completecases()** function returns an boolean array with value *true* for 
rows that have non-missing values and *false* otherwise. For those who are familiar
with R, this is the same behavior as the *complete.cases()* function from stats package. 

Another option to return the rows with non-missing values of a DataFrame in Julia
is to use the **dropmissing()** function:

```{julia}
dropmissing(x)
```

and again, for R users is the same behaviro as *na.omit()* function.



## Merging DataFrames:

Often, we need to combine two or more DataFrames together based on some common 
column(s) among them. For example, suppose we have two DataFrames:

```{julia}
df1 = DataFrame(x = 1:3, y = 4:6)
df2 = DataFrame(x = 1:3, z = 'd':'f', new = 11:13)
```
 which have the column *x* in common. To merge these two tables, we use the 
 **join()** function:

```{julia}
join(df1, df2, on = :x)
```

That it!! We merge our DataFrames altogether. But that's the default behavior of
the function. There is more to explore. Essentially, **join()** takes 4 arguments:

- DataFrame 1
- DataFrame 2
- on  = the column(s) to be the key in merging;
- kind = type of the merge (left, right, inner, outer, ...)

The *kind* argument specifies the type of join we are interested in performing. 
The definition of each one is as follows:


- *Inner*: The output contains rows for values of the key that exist
         in **BOTH** the first (left) and second (right) arguments to
         join;

- *Left*: The output contains rows for values of the key that exist in
       the first (left) argument to join, whether or not that value
       exists in the second (right) argument;

- *Right*: The output contains rows for values of the key that exist in
        the second (right) argument to join, whether or not that
        value exists  in the first (left) argument;

- *Outer*: The output contains rows for values of the key that exist in
        the first (left) **OR** second (right) argument to join;


and here are the strange ones:

- *Semi*: Like an inner join, but output is restricted to columns from
      the first (left) argument to join;

- *Anti*: The output contains rows for values of the key that exist in
       the  first (left) but **NOT** in the second (right) argument to
       join. As with  semi joins, output is restricted to columns
       from the first (left)  argument.


If you are familiar with *SQL* or with the join functions from *dplyr* package in R,
it is the same concept. 

To illustrate how the different kind of joins work, let's create more DataFrames 
to demonstrate each type of join:

```{julia}
Names = DataFrame(ID = [20, 40], Name = ["John Doe", "Jane Doe"])
jobs = DataFrame(ID = [20, 60], Job = ["Lawyer", "Astronaut"])
```

In the Names and jobs DataFrame, we have the ID column as the key to perform the
join. But notice that the ID values are not equal between the DataFrames. Now 
let's perform the joins:

```{julia}
join(Names, jobs, on = :ID, kind = :inner)
join(Names, jobs, on = :ID, kind = :left)
join(Names, jobs, on = :ID, kind = :right)
join(Names, jobs, on = :ID, kind = :outer)
```

*Semi* and *anti* join have a more uncommon behavior. Semi join returns the rows
 from the left which **DOES MATCHES** with the ID from the right:

```{julia}
join(Names, jobs, on = :ID, kind = :semi)
```
Anti join returns the rows from the left which **DOES NOT MATCH** with
the ID from the right

```{julia}
join(Names, jobs, on = :ID, kind = :anti)
```




## Split-Apply-Combine:

Some common tasks involve split the data into groups, applying some function 
to each of these groups and gather the results to analyze later on. This is the
split-apply-combine strategy described in the paper "[The Split-Apply-Combine Strategy for Data analysis](https://www.jstatsoft.org/article/view/v040i01)" written by Hadley Wickham, creator
of many R packages, including *ggplot2* and *dplyr*. 

The DataFrames package in Julia supports the Split-Apply-Combine strategy
through the **by()** function, which takes three arguments:

- DataFrame;
- one or more column names to split on;
- a function or expression to apply to each subset; 

To illustrate its usage, let's make use of the *RDatasets* package, which gives 
access to some preloaded well known datasets from R packages. 

```{julia} 
using RDatasets
foo = dataset("datasets", "iris");
foo |> head
```

A trivial task is to do is to find how many of each "Species" there are in the 
dataset. One way to do this is to apply the split-apply-combine strategy: **split**
the data into the *species* column, **apply** the *nrow()* function to this 
splitted dataset, and **combine** the results:

```{julia}
## Syntax: by(dataset, :name_column_to_split, name_function)
by(foo, :Species, nrow)
```

We can also use anonymous function:

```{julia}
by(foo, :Species, x -> DataFrame(N = nrow(x)))
```

One of the advantages of using anonymous function inside the *by()* function is 
that we can format the resulted output and apply as many function as we want:

```{julia}
## Applying the count, mean and standard deviation function:
by(foo, :Species, x -> DataFrame(N = nrow(x),
                                 avg_PetalLength = mean(x[:PetalLength]),
                                 std_PetalWidth = std(x[:PetalWidth])))
```


Another way to use the Split-Apply-Combine strategy is implementing the 
**aggregate()** function, which also takes three arguments:

- DataFrame;
- one or more column names to split on;
- one or more function to be applied **ON THE COLUMNS NOT USED TO SPLIT**.

The difference between *by()* and *aggregate()* function is that in the
latter, the function(s) will be applied to each column not used in
the split part. 

For instance, let's say you want the average of each colum for each *Species*. 
Instead of using *by()* with an anonymous function and writing the name of all columns
we can do:

```{julia}
aggregate(foo, :Species, [mean])
```

Note that Julia only display output that fits the screen. Pay
attention to the message "*Omitted printing of 1 columns*". To
overcome this, use the *show()* as advised before. 


# Reading and Writting CSV files:

Last but not least, let's see how to read and write CSV files into/from Julia.
Although this is not exactly handled by the *DataFrames* package, the task of
reading/writing CSV files are so natural when working with DataFrame that I will
show you the basics. 

To read/write CSV files, we use the **CSV** package. To demonstrate its usage, 
let's work with the iris dataset and write a CSV file to a local computer. Then,
we read it back.


So, first we are going to write the *foo* object (which contains the *iris* dataset)
to a CSV file. To do this we will use the **CSV.write()** function. Some useful 
arguments in CSV.write are:

- *delim* : the file's delimeter. Default ','.
- *header* : boolean whether to write the colnames from source;
- *colnames* : provide colnames to be written;
- *append* : bool to indicate if it to append data;
- *missingstring* : string that indicates how missing values will be represented.


```{julia, eval = F}
using CSV
CSV.write("./iris.csv", foo, missingsstring = "NA")
```

To read a CSV file, we use the **CSV.read()**. Some useful arguments are:

- *delim* : a Char or String that indicates how columns are delimited in a file
            file's delimeter. Default ',';
- *decimal* : a Char indicating how decimals are separated in
              floats. Default '.' ;
- *limit* : indicates the total number of rows to read;
- *header* : provide manually the names of the columns.
- *types* : a Vector or Dict of types to be used for column types.

```{julia}
iris = CSV.read("./iris.csv")
```

It is important to note that when loading in a DataFrame from a CSV, all columns 
allow Missing by default. 

This is the basics of reading/writting CSV files in Julia. To get more details
refers to the [official documentation](http://juliadata.github.io/CSV.jl/latest/#High-level-interface-1).

# Conclusion:



This post was a very small introduction to the **DataFrames** packages in Julia. 
After reading this post you will be able to read CSV datasets and perform some 
tasks with the data at hand. 

In the following posts, we will explore more advanced tricks to perform data 
wrangling and exploratory data analysis. At each step we are going to build 
knowledge to completely use Julia to perform data analysis for any problem that 
you might face.






